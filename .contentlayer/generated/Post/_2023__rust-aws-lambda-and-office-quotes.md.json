{
  "title": "Rust, AWS Lambda, and too many Office quotes",
  "description": "Identity theft is not a joke, Jim!",
  "pubDate": "2023-11-02T07:00:00.000Z",
  "category": "aws",
  "heroImage": "/images/rust-aws-lambda-office-quotes/meme.jpeg",
  "draft": false,
  "keywords": [
    "rust",
    "aws lambda",
    "terraform"
  ],
  "body": {
    "raw": "\nBack from a hard fought battle against writer's block, I've been looking for a way to convince my boss to let me use\nRust at work.\nMost of our infrastructure is on AWS (_surprised pikachu face_) and I've been writing a lot of new system features\ndesigned\nto run serverlessly with things like Lambda, Step Functions, SQS, SNS, and all the other band members we know and love.\nWe're a .NET shop, so moving to Rust wouldn't exactly be an overnight transition, nor would I want to force my zealotry\nupon my fellow developers.\n\nMy days are mostly spent raising a newly added member to my family, and I needed a reason to stay up late staring at my\nlaptop\nwhile watching The Office reruns. Then it dawned on me... what if I could combine my two favorite things in Rust and The\nOffice?\nIt might sound crazy, but we're all about technological experimentation around these parts.\n\nThe outcome of that experiment was a Lambda deployed to AWS fronted by an API Gateway available to make requests to and\nget\nrandom quotes from The Office out. A request might look like:\n\n```shell\n$ curl -l \"https://{{gateway URL}}/quotes\" | jq .\n{\n    \"author\": \"Prison Mike\",\n    \"quote\": \"The worst thing about prison was the Dementors.\"\n}\n```\n\nWith the help [cargo lambda](https://www.cargo-lambda.info/guide/getting-started.html), I was surprised at how easy it\nwas to get up and running with Lambdas that were even more easily deployed to AWS. As an added bonus, I sprinkled in\nsome [Terraform](https://www.terraform.io/) because I'm lazy and don't know which buttons to click in AWS most of the\ntime. If you're following along, it'll help to have the following installed:\n\n-   Cargo and cargo lambda installed (a quick `cargo install cargo-lambda` should do the trick)\n-   Terraform CLI\n-   An AWS account (I'm still on the free tier, for now...)\n\nWe'll touch the surface of a few things here, but won't be going into depth necessarily on any one topic. There's people\na lot smarter than myself that are ackshually qualified to talk about Rust, AWS, and Terraform.\n\n## Getting started\n\nFirst thing's first, we're gonna need some Rust code to deploy. Let's spin up a new project with cargo lambda:\n\n```shell\n$ cargo lambda new office-quotes\n> Is this function an HTTP function? Yes\n```\n\nWe're prompted about the compute context of our Rust-based Lambda, which in our case, will be from an API Gateway\nrequest. Lambdas are compute services that can be triggered from any number of things in AWS like events from SNS. I\nplan to eventually display some random Office quotes for anyone visiting my website, so I'll make it available over the\nnetwork for my website to utilize.\n\nCracking open our `main.rs` file, we'll see a pretty bare bones scaffolded Rust application:\n\n```rust\nuse lambda_http::{run, service_fn, Body, Error, Request, RequestExt, Response};\n\n/// This is the main body for the function.\n/// Write your code inside it.\n/// There are some code example in the following URLs:\n/// - https://github.com/awslabs/aws-lambda-rust-runtime/tree/main/examples\nasync fn function_handler(event: Request) -> Result<Response<Body>, Error> {\n    // Extract some useful information from the request\n    let who = event\n        .query_string_parameters_ref()\n        .and_then(|params| params.first(\"name\"))\n        .unwrap_or(\"world\");\n    let message = format!(\"Hello {who}, this is an AWS Lambda HTTP request\");\n\n    // Return something that implements IntoResponse.\n    // It will be serialized to the right response event automatically by the runtime\n    let resp = Response::builder()\n        .status(200)\n        .header(\"content-type\", \"text/html\")\n        .body(message.into())\n        .map_err(Box::new)?;\n    Ok(resp)\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::INFO)\n        // disable printing the name of the module in every log line.\n        .with_target(false)\n        // disabling time is handy because CloudWatch will add the ingestion time.\n        .without_time()\n        .init();\n\n    run(service_fn(function_handler)).await\n}\n```\n\nThe `event` our function receives is an HTTP request from the API gateway that has a bunch of metadata\nabout the request, like query strings, path parameters, where the request came from, body of the request, etc. Luckily,\nI ain't got time for all that noise - I want to simply return some quotes through a `GET` with an optional query\nparameter `author` to get character specific quotes.\n\nNext up, we're gonna need some quote data. Through the power of ChatGPT, I was able to generate a `quotes.json` file\nthat'll serve as our data source for quotes. When we eventually (inevitably?) choose to exercise our ability to\nprematurely optimize our solution, we'll add in connectors to a plethora of different data sources on the off chance we\nneed to support multiple databases, caches, flat files, etc.\n\nOur quotes file is pretty standard JSON:\n\n#### quotes.json\n\n```json\n{\n    \"quotes\": [\n        {\n            \"quote\": \"Would I rather be feared or loved? Easy. Both. I want people to be afraid of how much they love me.\",\n            \"author\": \"Michael Scott\"\n        },\n        {\n            \"quote\": \"Whenever I'm about to do something, I think, 'Would an idiot do that?' and if they would, I do not do that thing.\",\n            \"author\": \"Dwight Schrute\"\n        }\n        // And many more...\n    ]\n}\n```\n\nPlacing that at the root of our project directly next to `Cargo.toml` should do the trick so we can read it in, parse it\ninto a `struct` of sorts, and spit out some data on the other side when a request comes in. I'm gonna add a few crates\nto help me out:\n\n```\n$ cargo add anyhow # To make error handling a little easier\n$ cargo add rand # To help us pick random quotes if no author is provided via query param\n$ cargo add serde --features macros # To help us read in JSON quotes to Rust structs\n$ cargo add serde_json # To help us write data out in the response the AWS Rust runtime expects\n```\n\nWith our crates in place, next let's add a file for parsing quote data from the quotes file:\n\n#### src/quotes.rs\n\n```rust\nuse std::{env::current_dir, fs::File, io::Read};\n\nuse anyhow::Context;\nuse rand::Rng;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Quote {\n    pub author: String,\n    quote: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct QuotesData {\n    quotes: Vec<Quote>,\n}\n\nimpl QuotesData {\n    pub fn get_random_quote(&self) -> Quote {\n        let random_index = rand::thread_rng().gen_range(0..self.quotes.len());\n        self.quotes[random_index].clone()\n    }\n\n    pub fn get_quote_by(&self, author: &str) -> Option<Quote> {\n        self.quotes\n            .clone()\n            .into_iter()\n            .find(|q| q.author.to_lowercase().contains(&author.to_lowercase()))\n    }\n}\n\npub fn get_quotes() -> anyhow::Result<QuotesData> {\n    let quotes_file_path = current_dir().context(\"unable to determine current directory\")?;\n\n    let mut file = File::open(format!(\n        \"{}/quotes.json\",\n        quotes_file_path.to_str().unwrap()\n    ))\n    .context(\"unable to read quotes file\")?;\n\n    let mut file_contents = String::new();\n\n    file.read_to_string(&mut file_contents)\n        .context(\"unable to read the file contents into buffer\")?;\n\n    serde_json::from_str::<QuotesData>(&file_contents).context(\"unable to parse quotes\")\n}\n```\n\nNothing too fancy here. We're defining a few `struct`s to hold our quote data in `Quote` and `QuoteData`, while `impl`'\ning some functions on `QuoteData` to get us a quote when asked for one either from a specific author, or a random quote.\n\nFinally, we export a function for parsing the quotes file into our `QuotesData` stuct so we can do some logic with it\nlater. I should note that this isn't exactly the most exciting data, nor the most practical. You're probably already\nasking yourself \"wait... so we're parsing JSON data into Rust structs only to... return JSON data in the response?\" Yes,\nthat's _exactly_ what we're doing. Don't ask me why.\n\nOkay, so we have the ability to read the quotes file, now let's update our entrypoint into the function that will\ndetermine the context of the request and grab a quote:\n\n```rust\nmod quotes;\n\nuse anyhow::Context;\nuse lambda_http::{run, service_fn, Body, Error, Request, RequestExt, Response};\nuse quotes::get_quotes;\nuse serde_json::json;\nuse tracing::info;\n\n/// This is the main body for the function.\n/// Write your code inside it.\n/// There are some code example in the following URLs:\n/// - https://github.com/awslabs/aws-lambda-rust-runtime/tree/main/examples\nasync fn function_handler(event: Request) -> Result<Response<Body>, Error> {\n    info!(\"received request to get office quotes, loading quote data\");\n\n    // Load the quotes from our JSON file\n    let quotes = get_quotes()?;\n\n    // Grab a quote if an author name was sent along in the query params\n    // If no author is sent, we'll grab a random quote from the JSON\n    let quote = match event\n        .query_string_parameters_ref()\n        .and_then(|params| params.first(\"author\"))\n    {\n        Some(author) => {\n            info!(\"requested to retrieve quotes by author {author}\");\n            quotes.get_quote_by(author)\n        }\n        None => {\n            info!(\"no author specified, retrieving a random quote\");\n            Some(quotes.get_random_quote())\n        }\n    };\n\n    // Fineally, determine the response based on the authored quote we generated\n    // If we successfully generated a quote, wrap it up in a nice JSON response\n    // In the case an author was passed in via query param but no quote was found,\n    // return an error response in JSON format with the help of serde_json's `json!()` macro\n    match quote {\n        Some(authored_quote) => {\n            info!(\"quote retrieved by author {}\", &authored_quote.author);\n\n            let resp = Response::builder()\n                .status(200)\n                .header(\"content-type\", \"application/json\")\n                .body(\n                    serde_json::to_string(&authored_quote)\n                        .context(\"unable to serialize the hilarious quote\")?\n                        .into(),\n                )\n                .context(\"error attempting to build response body\")?;\n\n            Ok(resp)\n        }\n        None => {\n            let resp = Response::builder()\n                .status(404)\n                .header(\"content-type\", \"application/json\")\n                .body(\n                    json!({\n                        \"error\": \"Quote by that author does not exist.\"\n                    })\n                    .to_string()\n                    .into(),\n                )\n                .context(\"error attempting build the error response\")?;\n\n            Ok(resp)\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::INFO)\n        // disable printing the name of the module in every log line.\n        .with_target(false)\n        // disabling time is handy because CloudWatch will add the ingestion time.\n        .without_time()\n        .init();\n\n    info!(\"bootstrapping lambda\");\n\n    run(service_fn(function_handler)).await\n}\n```\n\nAgain, nothing too fancy here. At the top level, we're inspecting the request for query parameters and if one was sent,\nfind a quote by that author from the JSON we parsed. If no author sent, generate a random quote. Finally, we'll return\nJSON the API gateway based on the result of the request, falling back\nto an error if an author was provided but no quote was found. I've sprinkled in some `.context()?` utilities to help us\nearly return from unexpected errors with the help of `anyhow`. In a more robust application, we'd probably want to do\nsome more fine-grained error handling. Cargo lambda conveniently bundles the `tracing` crate into our functions, so\nwe're\nable to spit out some logs as well that will feed into a CloudWatch log group.\n\nNow that we've got our function in place, let's test it out. `cargo lambda` has some sweet utilities to help us out,\nincluding a `watch` command:\n\n```shell\n$ cargo lambda watch\nINFO invoke server listening on [::]:9000\nINFO starting lambda function function=\"_\" manifest=\"Cargo.toml\"\nCompiling office-quotes v0.1.0 (/home/jmckenzie/typescript/joey-mckenzie-tech/examples/rust/with-aws-lambda)\nFinished dev [unoptimized + debuginfo] target(s) in 1.40s\n    Running `target/debug/office-quotes`\nINFO bootstrapping lambda\n```\n\nAnd if we ping `localhost:9000`:\n\n```shell\n$ curl -l \"localhost:9000\" | jq .\n{\n  \"author\": \"Michael Scott\",\n  \"quote\": \"Would I rather be feared or loved? Easy. Both. I want people to be afraid of how much they love me.\"\n}\n```\n\nLet's verify the query parameters are making it into the request as well:\n\n```shell\n$ curl -l \"localhost:9000?author=kelly\" | jq .\n{\n  \"author\": \"Kelly Kapoor\",\n  \"quote\": \"I talk a lot, so I've learned to just tune myself out...\"\n}\n```\n\nLastly, let's check the error case where no author is found\n\n```shell\n$ curl -l \"localhost:9000?author=ron\" | jq .\n{\n  \"error\": \"Quote by that author does not exist.\"\n}\n```\n\nNice! We've got ourselves an MVP, time to ship to production.\n\n## Deploying to AWS\n\nWith our deployment approach, we'll do something akin to the following:\n\n-   Build the output artifact with the help of `cargo lambda`\n-   Package up the output into a zip file to store in S3\n-   Upload the zip file into a bucket\n-   Setup an Lambda function using the zip file as the source executable\n-   Setup an API Gateway instance that proxies requests through to our Lambda function\n\nNow doing all that stuff manually is not _too_ tedious, but I've been writing a lot Terraform lately and thought it\nwould fun to Terraform-erize this process. If you're not familiar with Terraform, it's\na [Hashicorp](https://www.hashicorp.com/) product with the goal of making provisioned infrastructure easier to main\nthrough infrastructure as code, or IaC. Terraform uses a configuration language called Hashicorp Configuration\nLanguage, or HCL, to define the who/what/when/where/why/how of our AWS infrastructure.\n\nI like to think of Terraform as a recipe for what our AWS infrastructure should look like, while also having the ability\nto plan and\napply those infrastructure changes for us, saving us an uncountable amount of mouse clicks navigating through the AWS\nconsole.\n\nAn example piece of TF configuration might look like:\n\n```terraform\nresource \"aws_lambda_function\" \"office_quotes\" {\n  function_name = \"office-quotes\"\n\n  s3_bucket = aws_s3_bucket.lambda_bucket.id\n  s3_key    = aws_s3_object.lambda_office_quotes.key\n\n  handler = \"rust.handler\"\n  runtime = \"provided.al2\"\n\n  source_code_hash = data.archive_file.lambda_office_quotes.output_base64sha256\n\n  role = aws_iam_role.lambda_execution_policy.arn\n}\n```\n\nHere, we're defining a resource that happens to be a Lambda function called `office_quotes`. That Lambda has a function\nname of `office-quotes`, has its source files located in an S3 bucket (which we'll provision in just a minute), and runs\non an EC2 instance with the `provided.al2` runtime. There's some other stuff in there like the role, which defines the\nexecution policy invokers of the function should have, and an MD5 hash of the zip file output. I mentioned earlier that\nthis isn't necessarily a blog post about Terraform, so I'll leave\na [link](https://github.com/JoeyMckenzie/joeymckenzie.tech/tree/main/examples/rust/with-aws-lambda) to the example code\nhere.\n\nFollowing the plan above, first thing we need is an S3 bucket we can store our zipped up function code in. I'll create\na `bucket.tf` configuration file that will do just that:\n\n#### bucket.tf\n\n```terraform\nresource \"random_pet\" \"lambda_bucket_name\" {\n  prefix = \"rust-lambda\"\n}\n\nresource \"aws_s3_bucket\" \"lambda_bucket\" {\n  bucket = random_pet.lambda_bucket_name.id\n}\n\nresource \"aws_s3_bucket_ownership_controls\" \"lambda_bucket\" {\n  bucket = aws_s3_bucket.lambda_bucket.id\n  rule {\n    object_ownership = \"BucketOwnerPreferred\"\n  }\n}\n\nresource \"aws_s3_bucket_acl\" \"lambda_bucket\" {\n  depends_on = [aws_s3_bucket_ownership_controls.lambda_bucket]\n\n  bucket = aws_s3_bucket.lambda_bucket.id\n  acl    = \"private\"\n}\n\ndata \"archive_file\" \"lambda_office_quotes\" {\n  type = \"zip\"\n\n  source_dir  = \"${path.module}/../target/lambda/office-quotes\"\n  output_path = \"${path.module}/bootstrap.zip\"\n}\n\nresource \"aws_s3_object\" \"lambda_office_quotes\" {\n  bucket = aws_s3_bucket.lambda_bucket.id\n\n  key    = \"bootstrap.zip\"\n  source = data.archive_file.lambda_office_quotes.output_path\n\n  etag = filemd5(data.archive_file.lambda_office_quotes.output_path)\n}\n```\n\nThe first few `resource`s defined above describe the bucket name with the help of a couple randomly generated names and\npermissions on the bucket. The last few pieces of configuration define some `data` we're going to work with that happens\nto be an archive file and an object that will exist in that bucket that's just the zip file of our function code.\n\nYou may have noticed that the `source_dir` of our `archive_file` data that we'll need doesn't actually exist yet - let's\nbuild it! Within our parent directory (I usually stick all my Terraform specific stuff in a subdirectory of the project\nI'm working in) let's run a quick `cargo lambda build --release` to build the output we need.\n\nOnce the build finishes, you should notice an exectuable file named `bootstrap` should be present in\nyour `target/lambda/office-quotes` folder. `cargo lambda` offers different build configurations as well, allowing output\nformats to also be specified - we could also run the build with the `--output-format zip` flag to get a ready-to-upload\nfile with `bootstrap.zip`. Since we're leaning on Terraform to do the file zipping for us though, we'll take the default\ngenerated executable instead.\n\nWith our bucket configuration in place, let's define our Lambda function configuration:\n\n#### lambda.tf\n\n```terraform\nresource \"aws_lambda_function\" \"office_quotes\" {\n  function_name = \"office-quotes\"\n\n  s3_bucket = aws_s3_bucket.lambda_bucket.id\n  s3_key    = aws_s3_object.lambda_office_quotes.key\n\n  handler = \"rust.handler\"\n  runtime = \"provided.al2\"\n\n  source_code_hash = data.archive_file.lambda_office_quotes.output_base64sha256\n\n  role = aws_iam_role.lambda_execution_policy.arn\n}\n\nresource \"aws_cloudwatch_log_group\" \"office_quotes\" {\n  name = \"/aws/lambda/${aws_lambda_function.office_quotes.function_name}\"\n\n  retention_in_days = 1\n}\n\nresource \"aws_iam_role\" \"lambda_execution_policy\" {\n  name               = \"office-lambda-execution-role\"\n  assume_role_policy = jsonencode({\n    Version   = \"2012-10-17\"\n    Statement = [\n      {\n        Action    = \"sts:AssumeRole\"\n        Effect    = \"Allow\"\n        Sid       = \"\"\n        Principal = {\n          Service = \"lambda.amazonaws.com\"\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"lambda_policy_attachment\" {\n  role = aws_iam_role.lambda_execution_policy.name\n\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n```\n\nAs we saw earlier, we'll use the same bit of function configuration and add a few things like CloudWatch logs and an\nexecution policy we'll expect services invoking the function to have.\n\nLet's hookup the final piece of infrastructure we'll need for now in an API Gateway resource:\n\n#### gateway.tf\n\n```terraform\nresource \"aws_apigatewayv2_api\" \"office_gateway\" {\n  name = \"office-gateway\"\n\n  protocol_type = \"HTTP\"\n}\n\nresource \"aws_apigatewayv2_stage\" \"office_gateway\" {\n  api_id = aws_apigatewayv2_api.office_gateway.id\n\n  name        = \"prod\"\n  auto_deploy = true\n\n  access_log_settings {\n    destination_arn = aws_cloudwatch_log_group.office_gateway.arn\n\n    format = jsonencode({\n      requestId               = \"$context.requestId\"\n      sourceIp                = \"$context.identity.sourceIp\"\n      requestTime             = \"$context.requestTime\"\n      protocol                = \"$context.protocol\"\n      httpMethod              = \"$context.httpMethod\"\n      resourcePath            = \"$context.resourcePath\"\n      routeKey                = \"$context.routeKey\"\n      status                  = \"$context.status\"\n      responseLength          = \"$context.responseLength\"\n      integrationErrorMessage = \"$context.integrationErrorMessage\"\n    }\n    )\n  }\n}\n\nresource \"aws_apigatewayv2_integration\" \"get_quote\" {\n  api_id = aws_apigatewayv2_api.office_gateway.id\n\n  integration_uri    = aws_lambda_function.office_quotes.invoke_arn\n  integration_type   = \"AWS_PROXY\"\n  integration_method = \"POST\"\n}\n\nresource \"aws_apigatewayv2_route\" \"get_quote\" {\n  api_id = aws_apigatewayv2_api.office_gateway.id\n\n  route_key = \"GET /quotes\"\n  target    = \"integrations/${aws_apigatewayv2_integration.get_quote.id}\"\n}\n\nresource \"aws_cloudwatch_log_group\" \"office_gateway\" {\n  name = \"/aws/api-gateway/${aws_apigatewayv2_api.office_gateway.name}\"\n\n  retention_in_days = 1\n}\n\nresource \"aws_lambda_permission\" \"office_gateway\" {\n  statement_id = \"AllowExecutionFromAPIGateway\"\n  action       = \"lambda:InvokeFunction\"\n\n  function_name = aws_lambda_function.office_quotes.function_name\n  principal     = \"apigateway.amazonaws.com\"\n\n  source_arn = \"${aws_apigatewayv2_api.office_gateway.execution_arn}/*/*\"\n}\n```\n\nOur API Gateway configuration is defined as a good ole fashioned HTTP API that has a route integration under\nthe `/quotes` path that will invoke our Lambda function. With the help of Terraform, we can reference bits of\ninfrastructure\ncreated in other files without needing to hard code or manually point to things.\n\nWhen we apply all of our Terraform infrastructure, we'll need a way to reference our created API Gateway without having\nto step into the AWS Console and click our way through to the API Gateway dashboard. Let's add an `outputs.tf` file\nthat tell Terraform that once all of our infrastructure is created, output it to the console for us. The created\nresources are also saved in our `terraform.tfstate` file as well, so we can also reference them there if need be.\n\n```terraform\noutput \"base_url\" {\n  description = \"Base URL for API Gateway stage.\"\n\n  value = aws_apigatewayv2_stage.office_gateway.invoke_url\n}\n\noutput \"lambda_bucket_name\" {\n  description = \"Name of the S3 bucket used to store function code.\"\n\n  value = aws_s3_bucket.lambda_bucket.id\n}\n```\n\nWhile we're at it, we'll go ahead and print out our bucket name as well as everytime we'll destroy/apply infrastructure,\nit'll change due to the random module we're leveraging to avoid clashing buckets. Now if we apply this plan, we should\nsee the fruits of our labor:\n\n```shell\n$ terraform apply -auto-approve\n\n# A bunch of logs about planned infrastructure...\n\nApply complete! Resources: 15 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nbase_url = \"https://dbyhxt543e.execute-api.us-west-1.amazonaws.com/prod\"\nlambda_bucket_name = \"rust-lambda-choice-cricket\"\n```\n\nAnd if I ping my URL (yours will be different) at the `/quotes` route:\n\n```shell\n$ curl -l \"https://dbyhxt543e.execute-api.us-west-1.amazonaws.com/prod/quotes\" | jq .\n{\n  \"author\": \"Dwight Schrute\",\n  \"quote\": \"Identity theft is not a joke, Jim! Millions of families suffer every year.\"\n}\n```\n\nSuccess! Rust, running on Lambda, publicly available through an API Gateway. This is great and all, but we need a way\nto reliably rebuild our infrastructure and apply changes. I'm going to define a `justfile`\nusing [just](https://github.com/casey/just)\nat the root of our project directory as I'm not smart enough to use `make`.\n\n#### justfile\n\n```shell\nalias b := build\n\ndefault: dev\n\n# build main\nbuild:\n    cargo lambda build --release && cp ./quotes.json ./target/lambda/office-quotes\n\n# build main\nbuild-deploy: build\n    just terraform/reapply\n\n# run the dev server\ndev:\n    cargo watch -x run\n\n# lint rust files\nclippy:\n    cargo clippy\n\n# check rust files format\ncheck:\n    cargo fmt -v --check\n\n# format rust files\nformat:\n    cargo fmt -v\n\n# run code quality tools\nci: check clippy\n```\n\n`just` is _just_ a convenient command runner, useful for aggregating things you'll run constantly in the terminal into a\nsingle source command. Instead of having to swap between `terraform` and `cargo` commands, `just` will allow me define a\nfew\ncommon commands to run so I can use things like `just build` or `just deploy` instead. I'm also going to define\nanother `justfile`\nwithin our `terraform` directory that will house all of the `terraform` commands we'll need to run:\n\n#### terraform/justfile\n\n```shell\ndefault: plan\n\n# run the plan\nplan:\n    terraform plan\n\n# apply the plan\napply:\n    terraform apply -auto-approve && sed -i '' \"s|^QUOTES_BASE_URL=.*|QUOTES_BASE_URL=$(terraform output -raw base_url)|\" ../../../../.env\n\n# destroy the plan\ndestroy:\n    terraform destroy -auto-approve\n\n# re-apply the plan\nreapply: destroy apply\n\n# format files\nfmt:\n    terraform fmt\n```\n\nOne could argue it's may not be the most fruitful idea to `-auto-approve` TF commands as it's essentially a force\ncommand,\nand we'd be better served running these things in CI through something like Terraform Cloud. I'm a one band on the AWS\nfree tier,\nthough, so I'll cut a few corners.\n\nBack in our root project directory, I can now run things like `just terraform/destory` or `just terraform/apply` without\nneeding\nto swap directories to run the different commands from the different `justfile`s. Let's verify our infrastructure is\nre-creatable,\nas that's where the true power of Terraform shines (in my opinion). Reliably re-creatable infrastructure empowers us to\nmove\nfast, especially when building in a multi-stage development environment.\n\n```shell\n$ just build-deploy\ncargo lambda build --release && cp ./quotes.json ./target/lambda/office-quotes\n    Finished release [optimized] target(s) in 0.12s\njust terraform/reapply\nterraform destroy -auto-approve\n// ...and a bunch of other TF output\n```\n\nWith our single `build-deploy` command, we'll:\n\n-   Compile our Rust code\n-   Build the expected output we need to zip and deploy to S3\n-   Copy over our JSON file for our Rust code to read from\n-   Destroy/recreate all of the required AWS infrastructure\n-   Deploy our zip file to the S3 bucket for our Lambda to use\n\nAgain, we'll see more output for the `base_url` and `lambda_bucket_name`, though with different IDs and names this time.\nI won't necessarily verify everything in AWS console, but we now have:\n\n-   A Lambda function that runs our zipped up Rust code from an S3 bucket\n-   An API Gateway instance that forwards requests to that Lambda\n-   CloudWatch log groups for both our API Gateway instance and our Lambda function\n\nAs a sanity check, let's make sure all the pipes are still hooked up by sending through another request to our gateway:\n\n```shell\n$ curl -l \"https://jcojq5szvk.execute-api.us-west-1.amazonaws.com/prod?author=michael\" | jq .\n{\n    \"author\": \"Michael Scott\",\n    \"quote\": \"I'm not superstitious...but I'm a little stitious.\"\n}\n```\n\nEz-pz, as the kids say! And with that, we've got Rust running on Lambda in AWS. The future of serverless Rust is looking\nbright! You can find all the source code for this example on my website examples\nin [GitHub](https://github.com/JoeyMckenzie/joeymckenzie.tech/tree/main/examples/rust/with-aws-lambda).\n\nUntil next time, friends!\n",
    "html": "<p>Back from a hard fought battle against writer's block, I've been looking for a way to convince my boss to let me use\nRust at work.\nMost of our infrastructure is on AWS (<em>surprised pikachu face</em>) and I've been writing a lot of new system features\ndesigned\nto run serverlessly with things like Lambda, Step Functions, SQS, SNS, and all the other band members we know and love.\nWe're a .NET shop, so moving to Rust wouldn't exactly be an overnight transition, nor would I want to force my zealotry\nupon my fellow developers.</p>\n<p>My days are mostly spent raising a newly added member to my family, and I needed a reason to stay up late staring at my\nlaptop\nwhile watching The Office reruns. Then it dawned on me... what if I could combine my two favorite things in Rust and The\nOffice?\nIt might sound crazy, but we're all about technological experimentation around these parts.</p>\n<p>The outcome of that experiment was a Lambda deployed to AWS fronted by an API Gateway available to make requests to and\nget\nrandom quotes from The Office out. A request might look like:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> curl</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> \"https://{{gateway URL}}/quotes\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> .</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">{</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    \"author\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"Prison Mike\",</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    \"quote\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"The worst thing about prison was the Dementors.\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>With the help <a href=\"https://www.cargo-lambda.info/guide/getting-started.html\">cargo lambda</a>, I was surprised at how easy it\nwas to get up and running with Lambdas that were even more easily deployed to AWS. As an added bonus, I sprinkled in\nsome <a href=\"https://www.terraform.io/\">Terraform</a> because I'm lazy and don't know which buttons to click in AWS most of the\ntime. If you're following along, it'll help to have the following installed:</p>\n<ul>\n<li>Cargo and cargo lambda installed (a quick <code>cargo install cargo-lambda</code> should do the trick)</li>\n<li>Terraform CLI</li>\n<li>An AWS account (I'm still on the free tier, for now...)</li>\n</ul>\n<p>We'll touch the surface of a few things here, but won't be going into depth necessarily on any one topic. There's people\na lot smarter than myself that are ackshually qualified to talk about Rust, AWS, and Terraform.</p>\n<h2>Getting started</h2>\n<p>First thing's first, we're gonna need some Rust code to deploy. Let's spin up a new project with cargo lambda:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> cargo</span><span style=\"color:#9ECBFF\"> lambda</span><span style=\"color:#9ECBFF\"> new</span><span style=\"color:#9ECBFF\"> office-quotes</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> Is this </span><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> an</span><span style=\"color:#E1E4E8\"> HTTP function? Yes</span></span></code></pre></figure>\n<p>We're prompted about the compute context of our Rust-based Lambda, which in our case, will be from an API Gateway\nrequest. Lambdas are compute services that can be triggered from any number of things in AWS like events from SNS. I\nplan to eventually display some random Office quotes for anyone visiting my website, so I'll make it available over the\nnetwork for my website to utilize.</p>\n<p>Cracking open our <code>main.rs</code> file, we'll see a pretty bare bones scaffolded Rust application:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"rust\" data-theme=\"github-dark\"><code data-language=\"rust\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> lambda_http</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">{run, service_fn, </span><span style=\"color:#B392F0\">Body</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">RequestExt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Response</span><span style=\"color:#E1E4E8\">};</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">/// This is the main body for the function.</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">/// Write your code inside it.</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">/// There are some code example in the following URLs:</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">/// - https://github.com/awslabs/aws-lambda-rust-runtime/tree/main/examples</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> function_handler</span><span style=\"color:#E1E4E8\">(event</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-></span><span style=\"color:#B392F0\"> Result</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Response</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Body</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Extract some useful information from the request</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    let</span><span style=\"color:#E1E4E8\"> who </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">query_string_parameters_ref</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">and_then</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">params</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> params</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">first</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">unwrap_or</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"world\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    let</span><span style=\"color:#E1E4E8\"> message </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> format!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Hello {who}, this is an AWS Lambda HTTP request\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Return something that implements IntoResponse.</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // It will be serialized to the right response event automatically by the runtime</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    let</span><span style=\"color:#E1E4E8\"> resp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Response</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">builder</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">status</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"content-type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/html\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">body</span><span style=\"color:#E1E4E8\">(message</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">into</span><span style=\"color:#E1E4E8\">())</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">map_err</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Box</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">new)</span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    Ok</span><span style=\"color:#E1E4E8\">(resp)</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">#[tokio</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">main]</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-></span><span style=\"color:#B392F0\"> Result</span><span style=\"color:#E1E4E8\">&#x3C;(), </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    tracing_subscriber</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">with_max_level</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">tracing</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">Level</span><span style=\"color:#F97583\">::</span><span style=\"color:#79B8FF\">INFO</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // disable printing the name of the module in every log line.</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">with_target</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // disabling time is handy because CloudWatch will add the ingestion time.</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">without_time</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">service_fn</span><span style=\"color:#E1E4E8\">(function_handler))</span><span style=\"color:#F97583\">.await</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>The <code>event</code> our function receives is an HTTP request from the API gateway that has a bunch of metadata\nabout the request, like query strings, path parameters, where the request came from, body of the request, etc. Luckily,\nI ain't got time for all that noise - I want to simply return some quotes through a <code>GET</code> with an optional query\nparameter <code>author</code> to get character specific quotes.</p>\n<p>Next up, we're gonna need some quote data. Through the power of ChatGPT, I was able to generate a <code>quotes.json</code> file\nthat'll serve as our data source for quotes. When we eventually (inevitably?) choose to exercise our ability to\nprematurely optimize our solution, we'll add in connectors to a plethora of different data sources on the off chance we\nneed to support multiple databases, caches, flat files, etc.</p>\n<p>Our quotes file is pretty standard JSON:</p>\n<h4>quotes.json</h4>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"json\" data-theme=\"github-dark\"><code data-language=\"json\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#E1E4E8\">{</span></span>\n<span data-line=\"\"><span style=\"color:#79B8FF\">    \"quotes\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#79B8FF\">            \"quote\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Would I rather be feared or loved? Easy. Both. I want people to be afraid of how much they love me.\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#79B8FF\">            \"author\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Michael Scott\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#79B8FF\">            \"quote\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Whenever I'm about to do something, I think, 'Would an idiot do that?' and if they would, I do not do that thing.\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#79B8FF\">            \"author\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Dwight Schrute\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // And many more...</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    ]</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Placing that at the root of our project directly next to <code>Cargo.toml</code> should do the trick so we can read it in, parse it\ninto a <code>struct</code> of sorts, and spit out some data on the other side when a request comes in. I'm gonna add a few crates\nto help me out:</p>\n<pre><code>$ cargo add anyhow # To make error handling a little easier\n$ cargo add rand # To help us pick random quotes if no author is provided via query param\n$ cargo add serde --features macros # To help us read in JSON quotes to Rust structs\n$ cargo add serde_json # To help us write data out in the response the AWS Rust runtime expects\n</code></pre>\n<p>With our crates in place, next let's add a file for parsing quote data from the quotes file:</p>\n<h4>src/quotes.rs</h4>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"rust\" data-theme=\"github-dark\"><code data-language=\"rust\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">env</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">current_dir, </span><span style=\"color:#B392F0\">fs</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">File</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">io</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">};</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> anyhow</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> rand</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">Rng</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> serde</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">Deserialize</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Serialize</span><span style=\"color:#E1E4E8\">};</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">#[derive(</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Clone</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Deserialize</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Serialize</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> Quote</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    pub</span><span style=\"color:#E1E4E8\"> author</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> String</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    quote</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> String</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">#[derive(</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Deserialize</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> QuotesData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    quotes</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Vec</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Quote</span><span style=\"color:#E1E4E8\">>,</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">impl</span><span style=\"color:#B392F0\"> QuotesData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> get_random_quote</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-></span><span style=\"color:#B392F0\"> Quote</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        let</span><span style=\"color:#E1E4E8\"> random_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> rand</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">thread_rng</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">gen_range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#F97583\">..</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#F97583\">.</span><span style=\"color:#E1E4E8\">quotes</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">());</span></span>\n<span data-line=\"\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#F97583\">.</span><span style=\"color:#E1E4E8\">quotes[random_index]</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">clone</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> get_quote_by</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">, author</span><span style=\"color:#F97583\">:</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">str</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-></span><span style=\"color:#B392F0\"> Option</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Quote</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span data-line=\"\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#F97583\">.</span><span style=\"color:#E1E4E8\">quotes</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            .</span><span style=\"color:#B392F0\">clone</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            .</span><span style=\"color:#B392F0\">into_iter</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            .</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">q</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> q</span><span style=\"color:#F97583\">.</span><span style=\"color:#E1E4E8\">author</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">to_lowercase</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">contains</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">author</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">to_lowercase</span><span style=\"color:#E1E4E8\">()))</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> get_quotes</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-></span><span style=\"color:#B392F0\"> anyhow</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">QuotesData</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    let</span><span style=\"color:#E1E4E8\"> quotes_file_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> current_dir</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unable to determine current directory\"</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    let</span><span style=\"color:#F97583\"> mut</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> File</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">format!</span><span style=\"color:#E1E4E8\">(</span></span>\n<span data-line=\"\"><span style=\"color:#9ECBFF\">        \"{}/quotes.json\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        quotes_file_path</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">to_str</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">unwrap</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    ))</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    .</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unable to read quotes file\"</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    let</span><span style=\"color:#F97583\"> mut</span><span style=\"color:#E1E4E8\"> file_contents </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> String</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    file</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">read_to_string</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;mut</span><span style=\"color:#E1E4E8\"> file_contents)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unable to read the file contents into buffer\"</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    serde_json</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">from_str</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">QuotesData</span><span style=\"color:#E1E4E8\">>(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">file_contents)</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unable to parse quotes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Nothing too fancy here. We're defining a few <code>struct</code>s to hold our quote data in <code>Quote</code> and <code>QuoteData</code>, while <code>impl</code>'\ning some functions on <code>QuoteData</code> to get us a quote when asked for one either from a specific author, or a random quote.</p>\n<p>Finally, we export a function for parsing the quotes file into our <code>QuotesData</code> stuct so we can do some logic with it\nlater. I should note that this isn't exactly the most exciting data, nor the most practical. You're probably already\nasking yourself \"wait... so we're parsing JSON data into Rust structs only to... return JSON data in the response?\" Yes,\nthat's <em>exactly</em> what we're doing. Don't ask me why.</p>\n<p>Okay, so we have the ability to read the quotes file, now let's update our entrypoint into the function that will\ndetermine the context of the request and grab a quote:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"rust\" data-theme=\"github-dark\"><code data-language=\"rust\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">mod</span><span style=\"color:#B392F0\"> quotes</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> anyhow</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> lambda_http</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">{run, service_fn, </span><span style=\"color:#B392F0\">Body</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">RequestExt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Response</span><span style=\"color:#E1E4E8\">};</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> quotes</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">get_quotes;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> serde_json</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">json;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">use</span><span style=\"color:#B392F0\"> tracing</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">info;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">/// This is the main body for the function.</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">/// Write your code inside it.</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">/// There are some code example in the following URLs:</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">/// - https://github.com/awslabs/aws-lambda-rust-runtime/tree/main/examples</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> function_handler</span><span style=\"color:#E1E4E8\">(event</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-></span><span style=\"color:#B392F0\"> Result</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Response</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Body</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    info!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"received request to get office quotes, loading quote data\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Load the quotes from our JSON file</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    let</span><span style=\"color:#E1E4E8\"> quotes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_quotes</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Grab a quote if an author name was sent along in the query params</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // If no author is sent, we'll grab a random quote from the JSON</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    let</span><span style=\"color:#E1E4E8\"> quote </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> match</span><span style=\"color:#E1E4E8\"> event</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">query_string_parameters_ref</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">and_then</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">params</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> params</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">first</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"author\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">        Some</span><span style=\"color:#E1E4E8\">(author) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">            info!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"requested to retrieve quotes by author {author}\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">            quotes</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">get_quote_by</span><span style=\"color:#E1E4E8\">(author)</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">        None</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">            info!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no author specified, retrieving a random quote\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">            Some</span><span style=\"color:#E1E4E8\">(quotes</span><span style=\"color:#F97583\">.</span><span style=\"color:#B392F0\">get_random_quote</span><span style=\"color:#E1E4E8\">())</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Fineally, determine the response based on the authored quote we generated</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // If we successfully generated a quote, wrap it up in a nice JSON response</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // In the case an author was passed in via query param but no quote was found,</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // return an error response in JSON format with the help of serde_json's `json!()` macro</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    match</span><span style=\"color:#E1E4E8\"> quote {</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">        Some</span><span style=\"color:#E1E4E8\">(authored_quote) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">            info!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"quote retrieved by author {}\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">authored_quote</span><span style=\"color:#F97583\">.</span><span style=\"color:#E1E4E8\">author);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">            let</span><span style=\"color:#E1E4E8\"> resp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Response</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">builder</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                .</span><span style=\"color:#B392F0\">status</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                .</span><span style=\"color:#B392F0\">header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"content-type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                .</span><span style=\"color:#B392F0\">body</span><span style=\"color:#E1E4E8\">(</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">                    serde_json</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">to_string</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">authored_quote)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                        .</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unable to serialize the hilarious quote\"</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">?</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                        .</span><span style=\"color:#B392F0\">into</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                .</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"error attempting to build response body\"</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">            Ok</span><span style=\"color:#E1E4E8\">(resp)</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">        None</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            let</span><span style=\"color:#E1E4E8\"> resp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Response</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">builder</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                .</span><span style=\"color:#B392F0\">status</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                .</span><span style=\"color:#B392F0\">header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"content-type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                .</span><span style=\"color:#B392F0\">body</span><span style=\"color:#E1E4E8\">(</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">                    json!</span><span style=\"color:#E1E4E8\">({</span></span>\n<span data-line=\"\"><span style=\"color:#9ECBFF\">                        \"error\"</span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"Quote by that author does not exist.\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">                    })</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                    .</span><span style=\"color:#B392F0\">to_string</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                    .</span><span style=\"color:#B392F0\">into</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                .</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"error attempting build the error response\"</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">            Ok</span><span style=\"color:#E1E4E8\">(resp)</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">#[tokio</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">main]</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-></span><span style=\"color:#B392F0\"> Result</span><span style=\"color:#E1E4E8\">&#x3C;(), </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    tracing_subscriber</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">with_max_level</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">tracing</span><span style=\"color:#F97583\">::</span><span style=\"color:#B392F0\">Level</span><span style=\"color:#F97583\">::</span><span style=\"color:#79B8FF\">INFO</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // disable printing the name of the module in every log line.</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">with_target</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // disabling time is handy because CloudWatch will add the ingestion time.</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">without_time</span><span style=\"color:#E1E4E8\">()</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        .</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    info!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bootstrapping lambda\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">service_fn</span><span style=\"color:#E1E4E8\">(function_handler))</span><span style=\"color:#F97583\">.await</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Again, nothing too fancy here. At the top level, we're inspecting the request for query parameters and if one was sent,\nfind a quote by that author from the JSON we parsed. If no author sent, generate a random quote. Finally, we'll return\nJSON the API gateway based on the result of the request, falling back\nto an error if an author was provided but no quote was found. I've sprinkled in some <code>.context()?</code> utilities to help us\nearly return from unexpected errors with the help of <code>anyhow</code>. In a more robust application, we'd probably want to do\nsome more fine-grained error handling. Cargo lambda conveniently bundles the <code>tracing</code> crate into our functions, so\nwe're\nable to spit out some logs as well that will feed into a CloudWatch log group.</p>\n<p>Now that we've got our function in place, let's test it out. <code>cargo lambda</code> has some sweet utilities to help us out,\nincluding a <code>watch</code> command:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> cargo</span><span style=\"color:#9ECBFF\"> lambda</span><span style=\"color:#9ECBFF\"> watch</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">INFO</span><span style=\"color:#9ECBFF\"> invoke</span><span style=\"color:#9ECBFF\"> server</span><span style=\"color:#9ECBFF\"> listening</span><span style=\"color:#9ECBFF\"> on</span><span style=\"color:#E1E4E8\"> [::]:9000</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">INFO</span><span style=\"color:#9ECBFF\"> starting</span><span style=\"color:#9ECBFF\"> lambda</span><span style=\"color:#9ECBFF\"> function</span><span style=\"color:#9ECBFF\"> function=\"_\"</span><span style=\"color:#9ECBFF\"> manifest=\"Cargo.toml\"</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">Compiling</span><span style=\"color:#9ECBFF\"> office-quotes</span><span style=\"color:#9ECBFF\"> v0.1.0</span><span style=\"color:#E1E4E8\"> (/home/jmckenzie/typescript/joey-mckenzie-tech/examples/rust/with-aws-lambda)</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">Finished</span><span style=\"color:#9ECBFF\"> dev</span><span style=\"color:#E1E4E8\"> [unoptimized </span><span style=\"color:#9ECBFF\">+</span><span style=\"color:#9ECBFF\"> debuginfo]</span><span style=\"color:#9ECBFF\"> target</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">s</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#9ECBFF\">in</span><span style=\"color:#79B8FF\"> 1.40</span><span style=\"color:#9ECBFF\">s</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    Running</span><span style=\"color:#9ECBFF\"> `</span><span style=\"color:#B392F0\">target/debug/office-quotes</span><span style=\"color:#9ECBFF\">`</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">INFO</span><span style=\"color:#9ECBFF\"> bootstrapping</span><span style=\"color:#9ECBFF\"> lambda</span></span></code></pre></figure>\n<p>And if we ping <code>localhost:9000</code>:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> curl</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> \"localhost:9000\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> .</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">{</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">  \"author\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"Michael Scott\",</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">  \"quote\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"Would I rather be feared or loved? Easy. Both. I want people to be afraid of how much they love me.\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Let's verify the query parameters are making it into the request as well:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> curl</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> \"localhost:9000?author=kelly\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> .</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">{</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">  \"author\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"Kelly Kapoor\",</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">  \"quote\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"I talk a lot, so I've learned to just tune myself out...\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Lastly, let's check the error case where no author is found</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> curl</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> \"localhost:9000?author=ron\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> .</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">{</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">  \"error\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"Quote by that author does not exist.\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Nice! We've got ourselves an MVP, time to ship to production.</p>\n<h2>Deploying to AWS</h2>\n<p>With our deployment approach, we'll do something akin to the following:</p>\n<ul>\n<li>Build the output artifact with the help of <code>cargo lambda</code></li>\n<li>Package up the output into a zip file to store in S3</li>\n<li>Upload the zip file into a bucket</li>\n<li>Setup an Lambda function using the zip file as the source executable</li>\n<li>Setup an API Gateway instance that proxies requests through to our Lambda function</li>\n</ul>\n<p>Now doing all that stuff manually is not <em>too</em> tedious, but I've been writing a lot Terraform lately and thought it\nwould fun to Terraform-erize this process. If you're not familiar with Terraform, it's\na <a href=\"https://www.hashicorp.com/\">Hashicorp</a> product with the goal of making provisioned infrastructure easier to main\nthrough infrastructure as code, or IaC. Terraform uses a configuration language called Hashicorp Configuration\nLanguage, or HCL, to define the who/what/when/where/why/how of our AWS infrastructure.</p>\n<p>I like to think of Terraform as a recipe for what our AWS infrastructure should look like, while also having the ability\nto plan and\napply those infrastructure changes for us, saving us an uncountable amount of mouse clicks navigating through the AWS\nconsole.</p>\n<p>An example piece of TF configuration might look like:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"terraform\" data-theme=\"github-dark\"><code data-language=\"terraform\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span>resource \"aws_lambda_function\" \"office_quotes\" {</span></span>\n<span data-line=\"\"><span>  function_name = \"office-quotes\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  s3_bucket = aws_s3_bucket.lambda_bucket.id</span></span>\n<span data-line=\"\"><span>  s3_key    = aws_s3_object.lambda_office_quotes.key</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  handler = \"rust.handler\"</span></span>\n<span data-line=\"\"><span>  runtime = \"provided.al2\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  source_code_hash = data.archive_file.lambda_office_quotes.output_base64sha256</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  role = aws_iam_role.lambda_execution_policy.arn</span></span>\n<span data-line=\"\"><span>}</span></span></code></pre></figure>\n<p>Here, we're defining a resource that happens to be a Lambda function called <code>office_quotes</code>. That Lambda has a function\nname of <code>office-quotes</code>, has its source files located in an S3 bucket (which we'll provision in just a minute), and runs\non an EC2 instance with the <code>provided.al2</code> runtime. There's some other stuff in there like the role, which defines the\nexecution policy invokers of the function should have, and an MD5 hash of the zip file output. I mentioned earlier that\nthis isn't necessarily a blog post about Terraform, so I'll leave\na <a href=\"https://github.com/JoeyMckenzie/joeymckenzie.tech/tree/main/examples/rust/with-aws-lambda\">link</a> to the example code\nhere.</p>\n<p>Following the plan above, first thing we need is an S3 bucket we can store our zipped up function code in. I'll create\na <code>bucket.tf</code> configuration file that will do just that:</p>\n<h4>bucket.tf</h4>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"terraform\" data-theme=\"github-dark\"><code data-language=\"terraform\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span>resource \"random_pet\" \"lambda_bucket_name\" {</span></span>\n<span data-line=\"\"><span>  prefix = \"rust-lambda\"</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_s3_bucket\" \"lambda_bucket\" {</span></span>\n<span data-line=\"\"><span>  bucket = random_pet.lambda_bucket_name.id</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_s3_bucket_ownership_controls\" \"lambda_bucket\" {</span></span>\n<span data-line=\"\"><span>  bucket = aws_s3_bucket.lambda_bucket.id</span></span>\n<span data-line=\"\"><span>  rule {</span></span>\n<span data-line=\"\"><span>    object_ownership = \"BucketOwnerPreferred\"</span></span>\n<span data-line=\"\"><span>  }</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_s3_bucket_acl\" \"lambda_bucket\" {</span></span>\n<span data-line=\"\"><span>  depends_on = [aws_s3_bucket_ownership_controls.lambda_bucket]</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  bucket = aws_s3_bucket.lambda_bucket.id</span></span>\n<span data-line=\"\"><span>  acl    = \"private\"</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>data \"archive_file\" \"lambda_office_quotes\" {</span></span>\n<span data-line=\"\"><span>  type = \"zip\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  source_dir  = \"${path.module}/../target/lambda/office-quotes\"</span></span>\n<span data-line=\"\"><span>  output_path = \"${path.module}/bootstrap.zip\"</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_s3_object\" \"lambda_office_quotes\" {</span></span>\n<span data-line=\"\"><span>  bucket = aws_s3_bucket.lambda_bucket.id</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  key    = \"bootstrap.zip\"</span></span>\n<span data-line=\"\"><span>  source = data.archive_file.lambda_office_quotes.output_path</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  etag = filemd5(data.archive_file.lambda_office_quotes.output_path)</span></span>\n<span data-line=\"\"><span>}</span></span></code></pre></figure>\n<p>The first few <code>resource</code>s defined above describe the bucket name with the help of a couple randomly generated names and\npermissions on the bucket. The last few pieces of configuration define some <code>data</code> we're going to work with that happens\nto be an archive file and an object that will exist in that bucket that's just the zip file of our function code.</p>\n<p>You may have noticed that the <code>source_dir</code> of our <code>archive_file</code> data that we'll need doesn't actually exist yet - let's\nbuild it! Within our parent directory (I usually stick all my Terraform specific stuff in a subdirectory of the project\nI'm working in) let's run a quick <code>cargo lambda build --release</code> to build the output we need.</p>\n<p>Once the build finishes, you should notice an exectuable file named <code>bootstrap</code> should be present in\nyour <code>target/lambda/office-quotes</code> folder. <code>cargo lambda</code> offers different build configurations as well, allowing output\nformats to also be specified - we could also run the build with the <code>--output-format zip</code> flag to get a ready-to-upload\nfile with <code>bootstrap.zip</code>. Since we're leaning on Terraform to do the file zipping for us though, we'll take the default\ngenerated executable instead.</p>\n<p>With our bucket configuration in place, let's define our Lambda function configuration:</p>\n<h4>lambda.tf</h4>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"terraform\" data-theme=\"github-dark\"><code data-language=\"terraform\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span>resource \"aws_lambda_function\" \"office_quotes\" {</span></span>\n<span data-line=\"\"><span>  function_name = \"office-quotes\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  s3_bucket = aws_s3_bucket.lambda_bucket.id</span></span>\n<span data-line=\"\"><span>  s3_key    = aws_s3_object.lambda_office_quotes.key</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  handler = \"rust.handler\"</span></span>\n<span data-line=\"\"><span>  runtime = \"provided.al2\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  source_code_hash = data.archive_file.lambda_office_quotes.output_base64sha256</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  role = aws_iam_role.lambda_execution_policy.arn</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_cloudwatch_log_group\" \"office_quotes\" {</span></span>\n<span data-line=\"\"><span>  name = \"/aws/lambda/${aws_lambda_function.office_quotes.function_name}\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  retention_in_days = 1</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_iam_role\" \"lambda_execution_policy\" {</span></span>\n<span data-line=\"\"><span>  name               = \"office-lambda-execution-role\"</span></span>\n<span data-line=\"\"><span>  assume_role_policy = jsonencode({</span></span>\n<span data-line=\"\"><span>    Version   = \"2012-10-17\"</span></span>\n<span data-line=\"\"><span>    Statement = [</span></span>\n<span data-line=\"\"><span>      {</span></span>\n<span data-line=\"\"><span>        Action    = \"sts:AssumeRole\"</span></span>\n<span data-line=\"\"><span>        Effect    = \"Allow\"</span></span>\n<span data-line=\"\"><span>        Sid       = \"\"</span></span>\n<span data-line=\"\"><span>        Principal = {</span></span>\n<span data-line=\"\"><span>          Service = \"lambda.amazonaws.com\"</span></span>\n<span data-line=\"\"><span>        }</span></span>\n<span data-line=\"\"><span>      }</span></span>\n<span data-line=\"\"><span>    ]</span></span>\n<span data-line=\"\"><span>  })</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_iam_role_policy_attachment\" \"lambda_policy_attachment\" {</span></span>\n<span data-line=\"\"><span>  role = aws_iam_role.lambda_execution_policy.name</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"</span></span>\n<span data-line=\"\"><span>}</span></span></code></pre></figure>\n<p>As we saw earlier, we'll use the same bit of function configuration and add a few things like CloudWatch logs and an\nexecution policy we'll expect services invoking the function to have.</p>\n<p>Let's hookup the final piece of infrastructure we'll need for now in an API Gateway resource:</p>\n<h4>gateway.tf</h4>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"terraform\" data-theme=\"github-dark\"><code data-language=\"terraform\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span>resource \"aws_apigatewayv2_api\" \"office_gateway\" {</span></span>\n<span data-line=\"\"><span>  name = \"office-gateway\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  protocol_type = \"HTTP\"</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_apigatewayv2_stage\" \"office_gateway\" {</span></span>\n<span data-line=\"\"><span>  api_id = aws_apigatewayv2_api.office_gateway.id</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  name        = \"prod\"</span></span>\n<span data-line=\"\"><span>  auto_deploy = true</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  access_log_settings {</span></span>\n<span data-line=\"\"><span>    destination_arn = aws_cloudwatch_log_group.office_gateway.arn</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>    format = jsonencode({</span></span>\n<span data-line=\"\"><span>      requestId               = \"$context.requestId\"</span></span>\n<span data-line=\"\"><span>      sourceIp                = \"$context.identity.sourceIp\"</span></span>\n<span data-line=\"\"><span>      requestTime             = \"$context.requestTime\"</span></span>\n<span data-line=\"\"><span>      protocol                = \"$context.protocol\"</span></span>\n<span data-line=\"\"><span>      httpMethod              = \"$context.httpMethod\"</span></span>\n<span data-line=\"\"><span>      resourcePath            = \"$context.resourcePath\"</span></span>\n<span data-line=\"\"><span>      routeKey                = \"$context.routeKey\"</span></span>\n<span data-line=\"\"><span>      status                  = \"$context.status\"</span></span>\n<span data-line=\"\"><span>      responseLength          = \"$context.responseLength\"</span></span>\n<span data-line=\"\"><span>      integrationErrorMessage = \"$context.integrationErrorMessage\"</span></span>\n<span data-line=\"\"><span>    }</span></span>\n<span data-line=\"\"><span>    )</span></span>\n<span data-line=\"\"><span>  }</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_apigatewayv2_integration\" \"get_quote\" {</span></span>\n<span data-line=\"\"><span>  api_id = aws_apigatewayv2_api.office_gateway.id</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  integration_uri    = aws_lambda_function.office_quotes.invoke_arn</span></span>\n<span data-line=\"\"><span>  integration_type   = \"AWS_PROXY\"</span></span>\n<span data-line=\"\"><span>  integration_method = \"POST\"</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_apigatewayv2_route\" \"get_quote\" {</span></span>\n<span data-line=\"\"><span>  api_id = aws_apigatewayv2_api.office_gateway.id</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  route_key = \"GET /quotes\"</span></span>\n<span data-line=\"\"><span>  target    = \"integrations/${aws_apigatewayv2_integration.get_quote.id}\"</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_cloudwatch_log_group\" \"office_gateway\" {</span></span>\n<span data-line=\"\"><span>  name = \"/aws/api-gateway/${aws_apigatewayv2_api.office_gateway.name}\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  retention_in_days = 1</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>resource \"aws_lambda_permission\" \"office_gateway\" {</span></span>\n<span data-line=\"\"><span>  statement_id = \"AllowExecutionFromAPIGateway\"</span></span>\n<span data-line=\"\"><span>  action       = \"lambda:InvokeFunction\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  function_name = aws_lambda_function.office_quotes.function_name</span></span>\n<span data-line=\"\"><span>  principal     = \"apigateway.amazonaws.com\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  source_arn = \"${aws_apigatewayv2_api.office_gateway.execution_arn}/*/*\"</span></span>\n<span data-line=\"\"><span>}</span></span></code></pre></figure>\n<p>Our API Gateway configuration is defined as a good ole fashioned HTTP API that has a route integration under\nthe <code>/quotes</code> path that will invoke our Lambda function. With the help of Terraform, we can reference bits of\ninfrastructure\ncreated in other files without needing to hard code or manually point to things.</p>\n<p>When we apply all of our Terraform infrastructure, we'll need a way to reference our created API Gateway without having\nto step into the AWS Console and click our way through to the API Gateway dashboard. Let's add an <code>outputs.tf</code> file\nthat tell Terraform that once all of our infrastructure is created, output it to the console for us. The created\nresources are also saved in our <code>terraform.tfstate</code> file as well, so we can also reference them there if need be.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"terraform\" data-theme=\"github-dark\"><code data-language=\"terraform\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span>output \"base_url\" {</span></span>\n<span data-line=\"\"><span>  description = \"Base URL for API Gateway stage.\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  value = aws_apigatewayv2_stage.office_gateway.invoke_url</span></span>\n<span data-line=\"\"><span>}</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>output \"lambda_bucket_name\" {</span></span>\n<span data-line=\"\"><span>  description = \"Name of the S3 bucket used to store function code.\"</span></span>\n<span data-line=\"\"><span></span></span>\n<span data-line=\"\"><span>  value = aws_s3_bucket.lambda_bucket.id</span></span>\n<span data-line=\"\"><span>}</span></span></code></pre></figure>\n<p>While we're at it, we'll go ahead and print out our bucket name as well as everytime we'll destroy/apply infrastructure,\nit'll change due to the random module we're leveraging to avoid clashing buckets. Now if we apply this plan, we should\nsee the fruits of our labor:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> terraform</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -auto-approve</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># A bunch of logs about planned infrastructure...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">Apply</span><span style=\"color:#9ECBFF\"> complete!</span><span style=\"color:#9ECBFF\"> Resources:</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#9ECBFF\"> added,</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#9ECBFF\"> changed,</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#9ECBFF\"> destroyed.</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">Outputs:</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">base_url</span><span style=\"color:#9ECBFF\"> =</span><span style=\"color:#9ECBFF\"> \"https://dbyhxt543e.execute-api.us-west-1.amazonaws.com/prod\"</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">lambda_bucket_name</span><span style=\"color:#9ECBFF\"> =</span><span style=\"color:#9ECBFF\"> \"rust-lambda-choice-cricket\"</span></span></code></pre></figure>\n<p>And if I ping my URL (yours will be different) at the <code>/quotes</code> route:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> curl</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> \"https://dbyhxt543e.execute-api.us-west-1.amazonaws.com/prod/quotes\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> .</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">{</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">  \"author\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"Dwight Schrute\",</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">  \"quote\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"Identity theft is not a joke, Jim! Millions of families suffer every year.\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Success! Rust, running on Lambda, publicly available through an API Gateway. This is great and all, but we need a way\nto reliably rebuild our infrastructure and apply changes. I'm going to define a <code>justfile</code>\nusing <a href=\"https://github.com/casey/just\">just</a>\nat the root of our project directory as I'm not smart enough to use <code>make</code>.</p>\n<h4>justfile</h4>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#79B8FF\">alias</span><span style=\"color:#9ECBFF\"> b</span><span style=\"color:#9ECBFF\"> :=</span><span style=\"color:#9ECBFF\"> build</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#B392F0\">default:</span><span style=\"color:#9ECBFF\"> dev</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># build main</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">build:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    cargo</span><span style=\"color:#9ECBFF\"> lambda</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#79B8FF\"> --release</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">cp</span><span style=\"color:#9ECBFF\"> ./quotes.json</span><span style=\"color:#9ECBFF\"> ./target/lambda/office-quotes</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># build main</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">build-deploy:</span><span style=\"color:#9ECBFF\"> build</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    just</span><span style=\"color:#9ECBFF\"> terraform/reapply</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># run the dev server</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">dev:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    cargo</span><span style=\"color:#9ECBFF\"> watch</span><span style=\"color:#79B8FF\"> -x</span><span style=\"color:#9ECBFF\"> run</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># lint rust files</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">clippy:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    cargo</span><span style=\"color:#9ECBFF\"> clippy</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># check rust files format</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">check:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    cargo</span><span style=\"color:#9ECBFF\"> fmt</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> --check</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># format rust files</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">format:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    cargo</span><span style=\"color:#9ECBFF\"> fmt</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># run code quality tools</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">ci:</span><span style=\"color:#9ECBFF\"> check</span><span style=\"color:#9ECBFF\"> clippy</span></span></code></pre></figure>\n<p><code>just</code> is <em>just</em> a convenient command runner, useful for aggregating things you'll run constantly in the terminal into a\nsingle source command. Instead of having to swap between <code>terraform</code> and <code>cargo</code> commands, <code>just</code> will allow me define a\nfew\ncommon commands to run so I can use things like <code>just build</code> or <code>just deploy</code> instead. I'm also going to define\nanother <code>justfile</code>\nwithin our <code>terraform</code> directory that will house all of the <code>terraform</code> commands we'll need to run:</p>\n<h4>terraform/justfile</h4>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">default:</span><span style=\"color:#9ECBFF\"> plan</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># run the plan</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">plan:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    terraform</span><span style=\"color:#9ECBFF\"> plan</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># apply the plan</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">apply:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    terraform</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -auto-approve</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">sed</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#9ECBFF\"> \"s|^QUOTES_BASE_URL=.*|QUOTES_BASE_URL=$(</span><span style=\"color:#B392F0\">terraform</span><span style=\"color:#9ECBFF\"> output </span><span style=\"color:#79B8FF\">-raw</span><span style=\"color:#9ECBFF\"> base_url)|\"</span><span style=\"color:#9ECBFF\"> ../../../../.env</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># destroy the plan</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">destroy:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    terraform</span><span style=\"color:#9ECBFF\"> destroy</span><span style=\"color:#79B8FF\"> -auto-approve</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># re-apply the plan</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">reapply:</span><span style=\"color:#9ECBFF\"> destroy</span><span style=\"color:#9ECBFF\"> apply</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\"># format files</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">fmt:</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    terraform</span><span style=\"color:#9ECBFF\"> fmt</span></span></code></pre></figure>\n<p>One could argue it's may not be the most fruitful idea to <code>-auto-approve</code> TF commands as it's essentially a force\ncommand,\nand we'd be better served running these things in CI through something like Terraform Cloud. I'm a one band on the AWS\nfree tier,\nthough, so I'll cut a few corners.</p>\n<p>Back in our root project directory, I can now run things like <code>just terraform/destory</code> or <code>just terraform/apply</code> without\nneeding\nto swap directories to run the different commands from the different <code>justfile</code>s. Let's verify our infrastructure is\nre-creatable,\nas that's where the true power of Terraform shines (in my opinion). Reliably re-creatable infrastructure empowers us to\nmove\nfast, especially when building in a multi-stage development environment.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> just</span><span style=\"color:#9ECBFF\"> build-deploy</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">cargo</span><span style=\"color:#9ECBFF\"> lambda</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#79B8FF\"> --release</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">cp</span><span style=\"color:#9ECBFF\"> ./quotes.json</span><span style=\"color:#9ECBFF\"> ./target/lambda/office-quotes</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    Finished</span><span style=\"color:#9ECBFF\"> release</span><span style=\"color:#E1E4E8\"> [optimized] target(</span><span style=\"color:#B392F0\">s</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> 0.12s</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">just</span><span style=\"color:#9ECBFF\"> terraform/reapply</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">terraform</span><span style=\"color:#9ECBFF\"> destroy</span><span style=\"color:#79B8FF\"> -auto-approve</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">//</span><span style=\"color:#9ECBFF\"> ...and</span><span style=\"color:#9ECBFF\"> a</span><span style=\"color:#9ECBFF\"> bunch</span><span style=\"color:#9ECBFF\"> of</span><span style=\"color:#9ECBFF\"> other</span><span style=\"color:#9ECBFF\"> TF</span><span style=\"color:#9ECBFF\"> output</span></span></code></pre></figure>\n<p>With our single <code>build-deploy</code> command, we'll:</p>\n<ul>\n<li>Compile our Rust code</li>\n<li>Build the expected output we need to zip and deploy to S3</li>\n<li>Copy over our JSON file for our Rust code to read from</li>\n<li>Destroy/recreate all of the required AWS infrastructure</li>\n<li>Deploy our zip file to the S3 bucket for our Lambda to use</li>\n</ul>\n<p>Again, we'll see more output for the <code>base_url</code> and <code>lambda_bucket_name</code>, though with different IDs and names this time.\nI won't necessarily verify everything in AWS console, but we now have:</p>\n<ul>\n<li>A Lambda function that runs our zipped up Rust code from an S3 bucket</li>\n<li>An API Gateway instance that forwards requests to that Lambda</li>\n<li>CloudWatch log groups for both our API Gateway instance and our Lambda function</li>\n</ul>\n<p>As a sanity check, let's make sure all the pipes are still hooked up by sending through another request to our gateway:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> curl</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> \"https://jcojq5szvk.execute-api.us-west-1.amazonaws.com/prod?author=michael\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> .</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">{</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    \"author\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"Michael Scott\",</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    \"quote\"</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#9ECBFF\"> \"I'm not superstitious...but I'm a little stitious.\"</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Ez-pz, as the kids say! And with that, we've got Rust running on Lambda in AWS. The future of serverless Rust is looking\nbright! You can find all the source code for this example on my website examples\nin <a href=\"https://github.com/JoeyMckenzie/joeymckenzie.tech/tree/main/examples/rust/with-aws-lambda\">GitHub</a>.</p>\n<p>Until next time, friends!</p>"
  },
  "_id": "2023/rust-aws-lambda-and-office-quotes.md",
  "_raw": {
    "sourceFilePath": "2023/rust-aws-lambda-and-office-quotes.md",
    "sourceFileName": "rust-aws-lambda-and-office-quotes.md",
    "sourceFileDir": "2023",
    "contentType": "markdown",
    "flattenedPath": "2023/rust-aws-lambda-and-office-quotes"
  },
  "type": "Post",
  "url": "/blog/2023/rust-aws-lambda-and-office-quotes"
}