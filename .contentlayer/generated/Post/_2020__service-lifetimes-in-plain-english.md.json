{
  "title": ".NET Core service lifetimes in a nutshell",
  "description": "Learn to register your lifetimes accordingly with .NET Core's built-in dependency injection and IoC container.",
  "pubDate": "2020-09-23T07:00:00.000Z",
  "category": ".NET",
  "heroImage": "https://imgs.xkcd.com/comics/dependencies.png",
  "draft": false,
  "keywords": [
    "c#",
    ".net",
    "service lifetimes"
  ],
  "body": {
    "raw": "\nNo matter the side of the dependency injection debate fence you fall, you've probably worked with some .NET code that\nhad some form of object composition through DI at some point, or another. Heck, with libraries\nin [Autofac](https://autofac.org/) and .NET Core's dependency injection extension namespace, DI and service container\nregistration is a breeze with all the heavy lifting done virtually for us.\n\nIf you've been reading along for the past several posts, you're wondering why I'm _not_ writing about Blazor. Don't get\nme wrong, I've got quite a few ideas I'd like to get out on paper here as we venture off deeper into Blazor-land. I\nwanted to take a break from the Blazor-scape for a while and write a bit on a topic I've been quite curious about for\nsome time now. Admittedly, I've fallen victim to the mindset of defaulting most of my .NET Core services lifetimes to\nthe good ole fashioned `.AddTransient()` simply because I figured when in doubt, you can't go wrong with the transient\nlifetime.\n\nBut then I started thinking to myself: \"self, do you _really_ understand the difference between service lifetimes?\"\nWhile I thought I had a clear understanding of the basics going just off the docs, I really wanted to make sure I\nunderstood _why_ I was choosing the lifetimes I was for my services. Not only that, I wanted to understand what\ndifferent types of application scenarios called for particular lifetimes.\n\n> Disclaimer: I'm not an Autofac expert, so I'll just be covering services within the scope (no pun intended)\n> of `Microsoft.Extensions.DependencyInjection` for the remainder of this post\n\nIf you're not familiar with the differing service lifetimes one can choose from when registering a service in a .NET\nCore application, the team at Microsoft has provided us with three varieties: transient, scoped, and singleton service\nlifetimes. Before we breakdown each service lifetime and write a bit of code to help us better understand the difference\nin these service types, let's talk about _why_ we might want to use service registration in an application.\n\n## Dependency Injection and Inversion of Control\n\nNow, I like to preface often that I am in no way, shape, or form an expert in the field of software engineering. I write\nthe blog posts, for the most part, to help me better understand the .NET ecosystem and the tools I use on a daily basis.\nSo, before I go down the rabbit hole of service lifetimes, it might be best if we understand why we register services in\nthe first place using something like .NET Core's `ServiceCollection` type from\nthe `Microsoft.Extensions.DependencyInjection` namespace. I like to think of this service container implementation in\nthe following manner:\n\n&nbsp;\n\n![Dependency_injection_flow](/images/dependency-injection-service-lifetimes/dependency_inject.png)\n\n&nbsp;\n\nBreaking it down, starting from an incoming application request:\n\n1. Request comes in ultimately requiring the construction of an object to do some sort of application processing\n2. The object in question requires _another_ service object to be composed correctly\n3. Since we've registered that required service in the IoC container, the request object will ask for the service object\n   to be injected during construction time\n4. Once the service object has been supplied, the object can properly construct itself and continue on to do whatever\n   job it has been invoked to do\n\nWhat this means code wise for us .NET-ers is that we effectively need to supply registered services within a class'\nconstructor, where the service container will recognize there's a dependency on said registered service in order for the\ndependent class to be properly constructed. If that's not a circular explanation, I don't know what is.\n\nIn our .NET Core applications, we deal with registered service container objects and classes on a regular basis -\nASP.NET Core `Controller`s, Entity Framework Core's `DbContext`\ns, [MediatR's](https://github.com/jbogard/MediatR) `IRequest` object, and the list goes on. Thanks to the IoC container,\nthe details of how these objects are registered and requested at runtime are abstracted from us, allowing us to\neffectively construct our registered classes with any number of other registered services of our choosing. There's\nprobably something I'm missing here, but I'll let the experts chime in and fill the gaps where necessary.\n\n## Service lifetimes\n\nAlright, back to business. Like we mentioned, there are three service lifetimes we can access through the dependency\ninjection extension namespace in transient, scoped, and singleton. The plain english explanation is as follows:\n\n-   **transient** - these services are constructed anew _every_ single time they're request from the service container and\n    will never persist across registered containers (i.e. `ServiceCollection`s that have outlived the scope of one\n    another)\n-   **scoped** - services that are constructed once during the lifetime scope of a `ServiceCollection` and persist across\n    service requests each time they're requested within the lifetime scope of a service container\n-   **singleton** - services that are constructed only a single time during the lifetime of an application, and persistent\n    across service container lifetime scopes\n\nThat seems like a lot of hoobla, so let's see service lifetimes in action to really try and make sense of all of this.\n\n## An example console application\n\nLet's kick things off by creating a new console application. I'll be using Visual Studio for Mac to change things up a\nbit, and I'll create a simple console application using the `File > New Project`. I'll name my\nproject `DependencyInjectionServiceLifetimes` and let leave the rest of the defaults. Feel free to checkout\nthe [source code](https://github.com/JoeyMckenzie/DependencyInjectionServiceLifetimes) anytime.\n\nWith our application bootstrapped, we should see just a single class file with `Program.cs` and nothing else. Now, we\n_could_ do this demonstration using an ASP.NET Core project, but we want to keep things simple without much project\noverhead. Let's go ahead and add a package reference to the latest version of `Microsoft.Extensions.DependencyInjection`\nto our `.csproj` file using your preferred method. Again, I'll be using the Package Manager interface in VS for Mac, but\nyou're welcome to use the command line as well. Once we've a few got the package reference, let's go ahead and add\na `Services` folder to the root of our project.\n\nWith our `Services` folder in place, let's add three simple service classes that we'll each register with a different\nlifetime. Go ahead and create three classes underneath `Services`: `TransientService`, `ScopedService`,\nand `SingletonService` (creative, I know):\n\n### TransientService.cs\n\n```csharp\nusing System;\n\nnamespace DependencyInjectionServiceLifetimes.Services\n{\n    public class TransientService : IDisposable\n    {\n        public TransientService() =>\n            Console.WriteLine(\"Constructing a transient service...\");\n\n        public void Dispose() =>\n            Console.WriteLine(\"Disposing of transient service...\");\n    }\n}\n\n```\n\n### ScopedService.cs\n\n```csharp\nusing System;\n\nnamespace DependencyInjectionServiceLifetimes.Services\n{\n    public class ScopedService : IDisposable\n    {\n        public ScopedService() =>\n            Console.WriteLine(\"Constructing a scoped service...\");\n\n        public void Dispose() =>\n            Console.WriteLine(\"Disposing of scoped service...\");\n    }\n}\n\n```\n\n### SingletonService.cs\n\n```csharp\nusing System;\n\nnamespace DependencyInjectionServiceLifetimes.Services\n{\n    public class SingletonService : IDisposable\n    {\n        public SingletonService() =>\n            Console.WriteLine(\"Constructing a singleton service...\");\n\n        public void Dispose() =>\n            Console.WriteLine(\"Disposing of singleton service...\");\n    }\n}\n```\n\nAs we see, each of our services just informs us when they are constructed and disposed of, nothing else. Since we're\nonly exploring lifetimes, we don't need our services to do any sort of processing for the purposes of this post, so\nwe'll keep them nice and simple. We should point out that we're descending from an `IDisposable` parent in each\nservice - if we take a look at\nthe [`IServiceProvider`](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.iservicescope?view=dotnet-plat-ext-3.1)\ninterface in the `Microsoft.Extensions.DependencyInjection` library, we see that it also inherits from `IDisposable`.\nWhen we create our service container and reference a scoped provider instance, the service scope in reference will\ninternally call `Dispose` at the end of its lifetime and subsequently `Dispose` of all applicable services within this\nscope. We implement the `Dispose` method in each service simply for visibility to see this in action.\n\nLet's go ahead and replace the current code in `Program.cs` with the following to kick things off and see what's going\non with all this service registration and request business:\n\n### Program.cs\n\n```csharp\nusing System;\nusing System.Diagnostics;\nusing DependencyInjectionServiceLifetimes.Services;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace DependencyInjectionServiceLifetimes\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // Instantiate a service container and add each of our service lifetime types\n            var builder = new ServiceCollection();\n            builder.AddScoped<ScopedService>();\n            builder.AddTransient<TransientService>();\n            builder.AddSingleton<SingletonService>();\n\n            // Build our service container within the scope of our current program\n            using var serviceProvider = builder.BuildServiceProvider();\n\n            // Create a disposable instance of our service container and grab a couple of scoped references\n            Console.WriteLine(\"Building the first service container...\\n\");\n            using var firstScopedContainer = serviceProvider.CreateScope();\n        }\n    }\n}\n```\n\nInitially, all we're doing is instantiating a service container instance with our `builder` reference to a\nnew `ServiceCollection` object, and adding each of our services as their respective lifetimes to the service container.\nTypically, we'd use the `.Add{LifetimeScope}<IMyService, MyService>()` variant of the add method, but this will suffice\nfor our purposes - that's more a discussion of dependency inversion rather than injection and service lifetimes, maybe\nI'll save that for a rainy day. With our services added, we'll construct a scoped instance of our service container with\nthe line `using var serviceProvider = builder.BuildServiceProvider();`, only valid until the end of our program, or\nuntil we manually call `Dispose`. Once we have this scoped service provider reference, we'll grab _another_ scoped\ninstance of the container to mimic an application request coming in to do some processing, requiring the IoC container\nto pull services from.\n\nWhew, there's quite a bit going on in just those few lines of code, but with that out of the way, let's do something a\nbit more familiar to us - requesting scoped services. After we've created our `firstScopedContainer` reference, let's\ngrab a few scoped services from the container. Just below `firstScopedContainer`, let's add the following:\n\n```csharp\nusing System;\nusing System.Diagnostics;\nusing DependencyInjectionServiceLifetimes.Services;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace DependencyInjectionServiceLifetimes\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // Previous service setup...\n\n            // Create a disposable instance of our service container and grab a couple of scoped references\n            Console.WriteLine(\"Building the first service container...\\n\");\n            using var firstScopedContainer = serviceProvider.CreateScope();\n            var scopedServiceOne = firstScopedContainer.ServiceProvider.GetRequiredService<ScopedService>();\n            var scopedServiceTwo = firstScopedContainer.ServiceProvider.GetRequiredService<ScopedService>();\n\n            // Validate that our scoped services are the same object reference, existing within the same service container scope lifetime\n            Debug.Assert(scopedServiceOne == scopedServiceTwo);\n        }\n    }\n}\n```\n\nWith a couple references to our scoped services, fire up this application and see what's going on. Since I'm using\nVisual Studio for Mac, I'll go ahead and hit F5, but a simple `dotnet run` from the command line of your choice should\ndo the trick as well. Let's see what we get:\n\n```\nBuilding the first service container...\n\nConstructing a scoped service...\nDisposing of scoped service...\n```\n\nNotice how we only saw the constructor of `IScopedService` called once, as its only purpose was to inform us its\nconstructor was called. Recall that scoped services are constructed _once_ per request, where our `firstScopedContainer`\nis effectively playing the role of an application request to do some processing. Even though we requested\nthe `ScopedService` twice, our service container instantiated said service _one_ time, and upon requesting the same\nscoped service again with `scopedServiceTwo`, we got back the same reference to the previously\nconstructed `ScopedService` object. As our application lifecycle comes to an end, we see that the `Dispose` method of\nour `ScopedService` was called as our program cleans up its resources.\n\nIf you're unfamiliar debug assertions (i.e. the line `Debug.Assert(scopedServiceOne == scopedServiceTwo);`), it's quite\na useful tool provided by the `System.Diagnostics` namespace. Anytime we place a `Debug.Assert(bool condition)` within\nour code, our application will automatically break, similar to a hitting a breakpoint, when we run in debug mode and\nour `condition` evaluates to `false`. Note that this has no effect when running in a release configuration. Here, we use\nthe assertion to check that our scoped service references are in fact the same object reference, as scoped services are\nconstructed only a single time per application request.\n\nAlright, with our scoped services constructed, let's see what happens when we grab some references to our transient\nservices. Just below our debug assertion for our scoped services, let's add the following:\n\n```csharp\nusing System;\nusing System.Diagnostics;\nusing DependencyInjectionServiceLifetimes.Services;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace DependencyInjectionServiceLifetimes\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // Just below our Debug.Assert() line...\n\n            // Create our transient services are difference object references within the same service scope\n            var transientServiceOne = firstScopedContainer.ServiceProvider.GetRequiredService<TransientService>();\n            var transientServiceTwo = firstScopedContainer.ServiceProvider.GetRequiredService<TransientService>();\n\n            // Validate that our transient services are not the same object reference, newly created for each request from the container\n            Debug.Assert(transientServiceOne != transientServiceTwo);\n        }\n    }\n}\n```\n\nWith a couple of references to initialized to our `TransientService` retrieved from our service container, let's run our\napplication once more to see what's going on. Again, hitting F5 in Visual Studio:\n\n```\nBuilding the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\n```\n\nOkay, so we got a bit of different output this time. Notice that still we only get one instance constructed for\nour `ScopedService` type, but now we get _two_ constructed instances of our `TransientService` type. Recall that the\ntransient service lifetime will construct its registered service _per request_ from the container, regardless of request\nscope. In plain english, each time we request a transient service, we're getting a fresh, brand spanking new service\nobject. Again, we'll use a debug assertion to assert that our transient services are different object references just to\nbe sure. Once more, when our application lifecycle comes to an end, all the services are cleaned up, as we can see from\nthe three lines letting us know that each requested service had its `Dispose` method called.\n\nWith our transient services in place now, let's see what happens when we bring our singleton service into the mix. Just\nbelow the debug assertion for our transient services, let's add the following:\n\n```csharp\nusing System;\nusing System.Diagnostics;\nusing DependencyInjectionServiceLifetimes.Services;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace DependencyInjectionServiceLifetimes\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // Just below our Debug.Assert() line...\n\n            // Create our singleton services are the same object reference within the same service scope\n            var singletonServiceOne = firstScopedContainer.ServiceProvider.GetRequiredService<SingletonService>();\n            var singletonServiceTwo = firstScopedContainer.ServiceProvider.GetRequiredService<SingletonService>();\n\n            // Validate that our singleton services are the same object reference, existing for the lifetime of the application\n            Debug.Assert(singletonServiceOne == singletonServiceTwo);\n\n            // Dispose of our current service container and create a new one\n            firstScopedContainer.Dispose();\n        }\n    }\n}\n```\n\nRunning our code now should produce the following output:\n\n```\nBuilding the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nConstructing a singleton service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\nDisposing of singleton service...\n```\n\nNothing has changed with our scoped and transient service constructions, or disposals. The only new lines we see now are\nthe construction and disposal of our singleton service. It might be tempting to infer that singleton services and scoped\nservices might act similarly, but that's not the case. Recall that singleton services are constructed _once_ per\napplication lifetime. Our application lifetime only has one \"request\" coming in so far, and finishes its \"processing\"\nonce we hit the line `firstScopedContainer.Dispose();`. This is all fine and dandy, but what happens when we have\nmultiple request coming in?\n\nLet's add another request facade in our application and see what happens we ask for services. Just below the debug\nassertion for our singleton service, let's add the following:\n\n```csharp\nusing System;\nusing System.Diagnostics;\nusing DependencyInjectionServiceLifetimes.Services;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace DependencyInjectionServiceLifetimes\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // Just below our Debug.Assert() line...\n\n            // Create another scoped service container instance and grab a few more of our lifetime services for comparison\n            Console.WriteLine(\"\\nBuilding our second service container...\");\n            using var secondScopedContainer = serviceProvider.CreateScope();\n\n            // Create another scoped service instance and compare it's object reference to the previous scoped instances\n            Console.WriteLine(\"\\nGrabbing a reference to another scoped service...\");\n            var anotherScopedService = secondScopedContainer.ServiceProvider.GetRequiredService<ScopedService>();\n            Debug.Assert(anotherScopedService != scopedServiceOne && anotherScopedService != scopedServiceTwo);\n        }\n    }\n}\n```\n\nRunning our program now, we get the following:\n\n```\nBuilding the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nConstructing a singleton service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\n\nBuilding our second service container...\n\nGrabbing a reference to another scoped service...\nConstructing a scoped service...\nDisposing of scoped service...\nDisposing of singleton service...\n```\n\nCan you spot the difference in output now? After our first service scope has been disposed, we clean up our references\nto our transient and scoped services, but our singleton service lives on. When we create a new request scope and grab\nanother scoped service instance, our scoped service container creates _another_ scoped service for us, as our scoped\nservice lifetimes does _not_ persist across application request scopes. Once our program ends, we do our usual cleaning\nup of our newly requested scoped services, but notice now that our singleton service is disposed of _after_ our second\napplication \"request\" comes in and our application's life comes to end (harsh). Let's see what happens when we add\nanother transient service reference. Again, just below our last debug assertion:\n\n```csharp\nusing System;\nusing System.Diagnostics;\nusing DependencyInjectionServiceLifetimes.Services;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace DependencyInjectionServiceLifetimes\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // Just below our Debug.Assert() line...\n\n            // Create another transient service instance and compare it's object reference to the previous transient instances\n            Console.WriteLine(\"\\nGrabbing a reference to another transient service...\");\n            var anotherTransientService = secondScopedContainer.ServiceProvider.GetRequiredService<TransientService>();\n            Debug.Assert(anotherTransientService != transientServiceOne && anotherTransientService != transientServiceTwo);\n        }\n    }\n}\n```\n\nAnd once again, running this code we get:\n\n```\nBuilding the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nConstructing a singleton service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\n\nBuilding our second service container...\n\nGrabbing a reference to another scoped service...\nConstructing a scoped service...\n\nGrabbing a reference to another transient service...\nConstructing a transient service...\nDisposing of transient service...\nDisposing of scoped service...\nDisposing of singleton service...\n```\n\nFocusing on the output after our second scoped application request, we see that as we request another transient service,\nour service container constructs yet _another_ service instance for us, as transient services are instantiated each time\nthey're requested regardless of request scope. Once again, all of our request services from the second request scope are\ndisposed of as our application cleans up its resources. Lastly, let's add one more reference to our singleton service:\n\n```csharp\nusing System;\nusing System.Diagnostics;\nusing DependencyInjectionServiceLifetimes.Services;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace DependencyInjectionServiceLifetimes\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // Just below our Debug.Assert() line...\n\n            // Create another singleton service instance and compare it's object reference to the previous singleton instances\n            Console.WriteLine(\"\\nGrabbing a reference to another singleton service...\");\n            var anotherSingletonService = secondScopedContainer.ServiceProvider.GetRequiredService<SingletonService>();\n            Debug.Assert(anotherSingletonService == singletonServiceOne && anotherSingletonService == singletonServiceTwo);\n        }\n    }\n}\n```\n\nOnce again running this code, we get:\n\n```\nBuilding the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nConstructing a singleton service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\n\nBuilding our second service container...\n\nGrabbing a reference to another scoped service...\nConstructing a scoped service...\n\nGrabbing a reference to another transient service...\nConstructing a transient service...\n\nGrabbing a reference to another singleton service...\nDisposing of transient service...\nDisposing of scoped service...\nDisposing of singleton service...\n```\n\nAgain focusing on the output after we create another request scope, we see that even across requests, when we reference\na singleton service from our container, we get the same reference back from the first time it was constructed within the\nscope of our first request. Remember that singletons are created only _once_ per application lifetime, so we don't see\nthe call to the constructor once we request it once again from our second request scope. Nothing new with our resource\ncleanup either.\n\n## Wrapping up\n\nAnother day, another service lifetime explored. We've seen how different service lifetimes construct themselves at\nrequest time and are cleaned up by their respective resource manager. When registering service lifetimes, we have to put\nsome thought into what kind of lifetime scope it should. Would you want a service that utilizes `IDbConnection` to be a\nsingleton? Probably not, as you might have a few angry customers on your hands. After today, I know I'll be a little\nmore conscious about the lifetimes I choose.\n\nUntil next time, amigos!\n",
    "html": "<p>No matter the side of the dependency injection debate fence you fall, you've probably worked with some .NET code that\nhad some form of object composition through DI at some point, or another. Heck, with libraries\nin <a href=\"https://autofac.org/\">Autofac</a> and .NET Core's dependency injection extension namespace, DI and service container\nregistration is a breeze with all the heavy lifting done virtually for us.</p>\n<p>If you've been reading along for the past several posts, you're wondering why I'm <em>not</em> writing about Blazor. Don't get\nme wrong, I've got quite a few ideas I'd like to get out on paper here as we venture off deeper into Blazor-land. I\nwanted to take a break from the Blazor-scape for a while and write a bit on a topic I've been quite curious about for\nsome time now. Admittedly, I've fallen victim to the mindset of defaulting most of my .NET Core services lifetimes to\nthe good ole fashioned <code>.AddTransient()</code> simply because I figured when in doubt, you can't go wrong with the transient\nlifetime.</p>\n<p>But then I started thinking to myself: \"self, do you <em>really</em> understand the difference between service lifetimes?\"\nWhile I thought I had a clear understanding of the basics going just off the docs, I really wanted to make sure I\nunderstood <em>why</em> I was choosing the lifetimes I was for my services. Not only that, I wanted to understand what\ndifferent types of application scenarios called for particular lifetimes.</p>\n<blockquote>\n<p>Disclaimer: I'm not an Autofac expert, so I'll just be covering services within the scope (no pun intended)\nof <code>Microsoft.Extensions.DependencyInjection</code> for the remainder of this post</p>\n</blockquote>\n<p>If you're not familiar with the differing service lifetimes one can choose from when registering a service in a .NET\nCore application, the team at Microsoft has provided us with three varieties: transient, scoped, and singleton service\nlifetimes. Before we breakdown each service lifetime and write a bit of code to help us better understand the difference\nin these service types, let's talk about <em>why</em> we might want to use service registration in an application.</p>\n<h2>Dependency Injection and Inversion of Control</h2>\n<p>Now, I like to preface often that I am in no way, shape, or form an expert in the field of software engineering. I write\nthe blog posts, for the most part, to help me better understand the .NET ecosystem and the tools I use on a daily basis.\nSo, before I go down the rabbit hole of service lifetimes, it might be best if we understand why we register services in\nthe first place using something like .NET Core's <code>ServiceCollection</code> type from\nthe <code>Microsoft.Extensions.DependencyInjection</code> namespace. I like to think of this service container implementation in\nthe following manner:</p>\n<p> </p>\n<p><img src=\"/images/dependency-injection-service-lifetimes/dependency_inject.png\" alt=\"Dependency_injection_flow\"></p>\n<p> </p>\n<p>Breaking it down, starting from an incoming application request:</p>\n<ol>\n<li>Request comes in ultimately requiring the construction of an object to do some sort of application processing</li>\n<li>The object in question requires <em>another</em> service object to be composed correctly</li>\n<li>Since we've registered that required service in the IoC container, the request object will ask for the service object\nto be injected during construction time</li>\n<li>Once the service object has been supplied, the object can properly construct itself and continue on to do whatever\njob it has been invoked to do</li>\n</ol>\n<p>What this means code wise for us .NET-ers is that we effectively need to supply registered services within a class'\nconstructor, where the service container will recognize there's a dependency on said registered service in order for the\ndependent class to be properly constructed. If that's not a circular explanation, I don't know what is.</p>\n<p>In our .NET Core applications, we deal with registered service container objects and classes on a regular basis -\nASP.NET Core <code>Controller</code>s, Entity Framework Core's <code>DbContext</code>\ns, <a href=\"https://github.com/jbogard/MediatR\">MediatR's</a> <code>IRequest</code> object, and the list goes on. Thanks to the IoC container,\nthe details of how these objects are registered and requested at runtime are abstracted from us, allowing us to\neffectively construct our registered classes with any number of other registered services of our choosing. There's\nprobably something I'm missing here, but I'll let the experts chime in and fill the gaps where necessary.</p>\n<h2>Service lifetimes</h2>\n<p>Alright, back to business. Like we mentioned, there are three service lifetimes we can access through the dependency\ninjection extension namespace in transient, scoped, and singleton. The plain english explanation is as follows:</p>\n<ul>\n<li><strong>transient</strong> - these services are constructed anew <em>every</em> single time they're request from the service container and\nwill never persist across registered containers (i.e. <code>ServiceCollection</code>s that have outlived the scope of one\nanother)</li>\n<li><strong>scoped</strong> - services that are constructed once during the lifetime scope of a <code>ServiceCollection</code> and persist across\nservice requests each time they're requested within the lifetime scope of a service container</li>\n<li><strong>singleton</strong> - services that are constructed only a single time during the lifetime of an application, and persistent\nacross service container lifetime scopes</li>\n</ul>\n<p>That seems like a lot of hoobla, so let's see service lifetimes in action to really try and make sense of all of this.</p>\n<h2>An example console application</h2>\n<p>Let's kick things off by creating a new console application. I'll be using Visual Studio for Mac to change things up a\nbit, and I'll create a simple console application using the <code>File > New Project</code>. I'll name my\nproject <code>DependencyInjectionServiceLifetimes</code> and let leave the rest of the defaults. Feel free to checkout\nthe <a href=\"https://github.com/JoeyMckenzie/DependencyInjectionServiceLifetimes\">source code</a> anytime.</p>\n<p>With our application bootstrapped, we should see just a single class file with <code>Program.cs</code> and nothing else. Now, we\n<em>could</em> do this demonstration using an ASP.NET Core project, but we want to keep things simple without much project\noverhead. Let's go ahead and add a package reference to the latest version of <code>Microsoft.Extensions.DependencyInjection</code>\nto our <code>.csproj</code> file using your preferred method. Again, I'll be using the Package Manager interface in VS for Mac, but\nyou're welcome to use the command line as well. Once we've a few got the package reference, let's go ahead and add\na <code>Services</code> folder to the root of our project.</p>\n<p>With our <code>Services</code> folder in place, let's add three simple service classes that we'll each register with a different\nlifetime. Go ahead and create three classes underneath <code>Services</code>: <code>TransientService</code>, <code>ScopedService</code>,\nand <code>SingletonService</code> (creative, I know):</p>\n<h3>TransientService.cs</h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> TransientService</span><span style=\"color:#666666\"> :</span><span style=\"color:#5DA994\"> IDisposable</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        public</span><span style=\"color:#80A665\"> TransientService</span><span style=\"color:#666666\">()</span><span style=\"color:#CB7676\"> =></span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C98A7D\">Constructing a transient service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        public</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Dispose</span><span style=\"color:#666666\">()</span><span style=\"color:#CB7676\"> =></span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C98A7D\">Disposing of transient service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span>\n<span data-line=\"\"> </span></code></pre></figure>\n<h3>ScopedService.cs</h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> ScopedService</span><span style=\"color:#666666\"> :</span><span style=\"color:#5DA994\"> IDisposable</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        public</span><span style=\"color:#80A665\"> ScopedService</span><span style=\"color:#666666\">()</span><span style=\"color:#CB7676\"> =></span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C98A7D\">Constructing a scoped service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        public</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Dispose</span><span style=\"color:#666666\">()</span><span style=\"color:#CB7676\"> =></span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C98A7D\">Disposing of scoped service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span>\n<span data-line=\"\"> </span></code></pre></figure>\n<h3>SingletonService.cs</h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> SingletonService</span><span style=\"color:#666666\"> :</span><span style=\"color:#5DA994\"> IDisposable</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        public</span><span style=\"color:#80A665\"> SingletonService</span><span style=\"color:#666666\">()</span><span style=\"color:#CB7676\"> =></span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C98A7D\">Constructing a singleton service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        public</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Dispose</span><span style=\"color:#666666\">()</span><span style=\"color:#CB7676\"> =></span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C98A7D\">Disposing of singleton service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span></code></pre></figure>\n<p>As we see, each of our services just informs us when they are constructed and disposed of, nothing else. Since we're\nonly exploring lifetimes, we don't need our services to do any sort of processing for the purposes of this post, so\nwe'll keep them nice and simple. We should point out that we're descending from an <code>IDisposable</code> parent in each\nservice - if we take a look at\nthe <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.iservicescope?view=dotnet-plat-ext-3.1\"><code>IServiceProvider</code></a>\ninterface in the <code>Microsoft.Extensions.DependencyInjection</code> library, we see that it also inherits from <code>IDisposable</code>.\nWhen we create our service container and reference a scoped provider instance, the service scope in reference will\ninternally call <code>Dispose</code> at the end of its lifetime and subsequently <code>Dispose</code> of all applicable services within this\nscope. We implement the <code>Dispose</code> method in each service simply for visibility to see this in action.</p>\n<p>Let's go ahead and replace the current code in <code>Program.cs</code> with the following to kick things off and see what's going\non with all this service registration and request business:</p>\n<h3>Program.cs</h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Diagnostics</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> Microsoft</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Extensions</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">DependencyInjection</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> Program</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        static</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Main</span><span style=\"color:#666666\">(</span><span style=\"color:#4D9375\">string</span><span style=\"color:#666666\">[]</span><span style=\"color:#80A665\"> args</span><span style=\"color:#666666\">)</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Instantiate a service container and add each of our service lifetime types</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> builder</span><span style=\"color:#666666\"> =</span><span style=\"color:#CB7676\"> new</span><span style=\"color:#5DA994\"> ServiceCollection</span><span style=\"color:#666666\">();</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            builder</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">AddScoped</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">ScopedService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            builder</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">AddTransient</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">TransientService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            builder</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">AddSingleton</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">SingletonService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Build our service container within the scope of our current program</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">            using</span><span style=\"color:#CB7676\"> var</span><span style=\"color:#80A665\"> serviceProvider</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> builder</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">BuildServiceProvider</span><span style=\"color:#666666\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Create a disposable instance of our service container and grab a couple of scoped references</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C98A7D\">Building the first service container...</span><span style=\"color:#C99076\">\\n</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">            using</span><span style=\"color:#CB7676\"> var</span><span style=\"color:#80A665\"> firstScopedContainer</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> serviceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">CreateScope</span><span style=\"color:#666666\">();</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span></code></pre></figure>\n<p>Initially, all we're doing is instantiating a service container instance with our <code>builder</code> reference to a\nnew <code>ServiceCollection</code> object, and adding each of our services as their respective lifetimes to the service container.\nTypically, we'd use the <code>.Add{LifetimeScope}&#x3C;IMyService, MyService>()</code> variant of the add method, but this will suffice\nfor our purposes - that's more a discussion of dependency inversion rather than injection and service lifetimes, maybe\nI'll save that for a rainy day. With our services added, we'll construct a scoped instance of our service container with\nthe line <code>using var serviceProvider = builder.BuildServiceProvider();</code>, only valid until the end of our program, or\nuntil we manually call <code>Dispose</code>. Once we have this scoped service provider reference, we'll grab <em>another</em> scoped\ninstance of the container to mimic an application request coming in to do some processing, requiring the IoC container\nto pull services from.</p>\n<p>Whew, there's quite a bit going on in just those few lines of code, but with that out of the way, let's do something a\nbit more familiar to us - requesting scoped services. After we've created our <code>firstScopedContainer</code> reference, let's\ngrab a few scoped services from the container. Just below <code>firstScopedContainer</code>, let's add the following:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Diagnostics</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> Microsoft</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Extensions</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">DependencyInjection</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> Program</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        static</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Main</span><span style=\"color:#666666\">(</span><span style=\"color:#4D9375\">string</span><span style=\"color:#666666\">[]</span><span style=\"color:#80A665\"> args</span><span style=\"color:#666666\">)</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Previous service setup...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Create a disposable instance of our service container and grab a couple of scoped references</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C98A7D\">Building the first service container...</span><span style=\"color:#C99076\">\\n</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">            using</span><span style=\"color:#CB7676\"> var</span><span style=\"color:#80A665\"> firstScopedContainer</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> serviceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">CreateScope</span><span style=\"color:#666666\">();</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> scopedServiceOne</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> firstScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">ScopedService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> scopedServiceTwo</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> firstScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">ScopedService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Validate that our scoped services are the same object reference, existing within the same service container scope lifetime</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Debug</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">Assert</span><span style=\"color:#666666\">(</span><span style=\"color:#BD976A\">scopedServiceOne</span><span style=\"color:#CB7676\"> ==</span><span style=\"color:#BD976A\"> scopedServiceTwo</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span></code></pre></figure>\n<p>With a couple references to our scoped services, fire up this application and see what's going on. Since I'm using\nVisual Studio for Mac, I'll go ahead and hit F5, but a simple <code>dotnet run</code> from the command line of your choice should\ndo the trick as well. Let's see what we get:</p>\n<pre><code>Building the first service container...\n\nConstructing a scoped service...\nDisposing of scoped service...\n</code></pre>\n<p>Notice how we only saw the constructor of <code>IScopedService</code> called once, as its only purpose was to inform us its\nconstructor was called. Recall that scoped services are constructed <em>once</em> per request, where our <code>firstScopedContainer</code>\nis effectively playing the role of an application request to do some processing. Even though we requested\nthe <code>ScopedService</code> twice, our service container instantiated said service <em>one</em> time, and upon requesting the same\nscoped service again with <code>scopedServiceTwo</code>, we got back the same reference to the previously\nconstructed <code>ScopedService</code> object. As our application lifecycle comes to an end, we see that the <code>Dispose</code> method of\nour <code>ScopedService</code> was called as our program cleans up its resources.</p>\n<p>If you're unfamiliar debug assertions (i.e. the line <code>Debug.Assert(scopedServiceOne == scopedServiceTwo);</code>), it's quite\na useful tool provided by the <code>System.Diagnostics</code> namespace. Anytime we place a <code>Debug.Assert(bool condition)</code> within\nour code, our application will automatically break, similar to a hitting a breakpoint, when we run in debug mode and\nour <code>condition</code> evaluates to <code>false</code>. Note that this has no effect when running in a release configuration. Here, we use\nthe assertion to check that our scoped service references are in fact the same object reference, as scoped services are\nconstructed only a single time per application request.</p>\n<p>Alright, with our scoped services constructed, let's see what happens when we grab some references to our transient\nservices. Just below our debug assertion for our scoped services, let's add the following:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Diagnostics</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> Microsoft</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Extensions</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">DependencyInjection</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> Program</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        static</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Main</span><span style=\"color:#666666\">(</span><span style=\"color:#4D9375\">string</span><span style=\"color:#666666\">[]</span><span style=\"color:#80A665\"> args</span><span style=\"color:#666666\">)</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Just below our Debug.Assert() line...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Create our transient services are difference object references within the same service scope</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> transientServiceOne</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> firstScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">TransientService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> transientServiceTwo</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> firstScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">TransientService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Validate that our transient services are not the same object reference, newly created for each request from the container</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Debug</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">Assert</span><span style=\"color:#666666\">(</span><span style=\"color:#BD976A\">transientServiceOne</span><span style=\"color:#CB7676\"> !=</span><span style=\"color:#BD976A\"> transientServiceTwo</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span></code></pre></figure>\n<p>With a couple of references to initialized to our <code>TransientService</code> retrieved from our service container, let's run our\napplication once more to see what's going on. Again, hitting F5 in Visual Studio:</p>\n<pre><code>Building the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\n</code></pre>\n<p>Okay, so we got a bit of different output this time. Notice that still we only get one instance constructed for\nour <code>ScopedService</code> type, but now we get <em>two</em> constructed instances of our <code>TransientService</code> type. Recall that the\ntransient service lifetime will construct its registered service <em>per request</em> from the container, regardless of request\nscope. In plain english, each time we request a transient service, we're getting a fresh, brand spanking new service\nobject. Again, we'll use a debug assertion to assert that our transient services are different object references just to\nbe sure. Once more, when our application lifecycle comes to an end, all the services are cleaned up, as we can see from\nthe three lines letting us know that each requested service had its <code>Dispose</code> method called.</p>\n<p>With our transient services in place now, let's see what happens when we bring our singleton service into the mix. Just\nbelow the debug assertion for our transient services, let's add the following:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Diagnostics</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> Microsoft</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Extensions</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">DependencyInjection</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> Program</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        static</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Main</span><span style=\"color:#666666\">(</span><span style=\"color:#4D9375\">string</span><span style=\"color:#666666\">[]</span><span style=\"color:#80A665\"> args</span><span style=\"color:#666666\">)</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Just below our Debug.Assert() line...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Create our singleton services are the same object reference within the same service scope</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> singletonServiceOne</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> firstScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">SingletonService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> singletonServiceTwo</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> firstScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">SingletonService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Validate that our singleton services are the same object reference, existing for the lifetime of the application</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Debug</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">Assert</span><span style=\"color:#666666\">(</span><span style=\"color:#BD976A\">singletonServiceOne</span><span style=\"color:#CB7676\"> ==</span><span style=\"color:#BD976A\"> singletonServiceTwo</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Dispose of our current service container and create a new one</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            firstScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">Dispose</span><span style=\"color:#666666\">();</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span></code></pre></figure>\n<p>Running our code now should produce the following output:</p>\n<pre><code>Building the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nConstructing a singleton service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\nDisposing of singleton service...\n</code></pre>\n<p>Nothing has changed with our scoped and transient service constructions, or disposals. The only new lines we see now are\nthe construction and disposal of our singleton service. It might be tempting to infer that singleton services and scoped\nservices might act similarly, but that's not the case. Recall that singleton services are constructed <em>once</em> per\napplication lifetime. Our application lifetime only has one \"request\" coming in so far, and finishes its \"processing\"\nonce we hit the line <code>firstScopedContainer.Dispose();</code>. This is all fine and dandy, but what happens when we have\nmultiple request coming in?</p>\n<p>Let's add another request facade in our application and see what happens we ask for services. Just below the debug\nassertion for our singleton service, let's add the following:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Diagnostics</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> Microsoft</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Extensions</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">DependencyInjection</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> Program</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        static</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Main</span><span style=\"color:#666666\">(</span><span style=\"color:#4D9375\">string</span><span style=\"color:#666666\">[]</span><span style=\"color:#80A665\"> args</span><span style=\"color:#666666\">)</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Just below our Debug.Assert() line...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Create another scoped service container instance and grab a few more of our lifetime services for comparison</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C99076\">\\n</span><span style=\"color:#C98A7D\">Building our second service container...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">            using</span><span style=\"color:#CB7676\"> var</span><span style=\"color:#80A665\"> secondScopedContainer</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> serviceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">CreateScope</span><span style=\"color:#666666\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Create another scoped service instance and compare it's object reference to the previous scoped instances</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C99076\">\\n</span><span style=\"color:#C98A7D\">Grabbing a reference to another scoped service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> anotherScopedService</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> secondScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">ScopedService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Debug</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">Assert</span><span style=\"color:#666666\">(</span><span style=\"color:#BD976A\">anotherScopedService</span><span style=\"color:#CB7676\"> !=</span><span style=\"color:#BD976A\"> scopedServiceOne</span><span style=\"color:#CB7676\"> &#x26;&#x26;</span><span style=\"color:#BD976A\"> anotherScopedService</span><span style=\"color:#CB7676\"> !=</span><span style=\"color:#BD976A\"> scopedServiceTwo</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span></code></pre></figure>\n<p>Running our program now, we get the following:</p>\n<pre><code>Building the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nConstructing a singleton service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\n\nBuilding our second service container...\n\nGrabbing a reference to another scoped service...\nConstructing a scoped service...\nDisposing of scoped service...\nDisposing of singleton service...\n</code></pre>\n<p>Can you spot the difference in output now? After our first service scope has been disposed, we clean up our references\nto our transient and scoped services, but our singleton service lives on. When we create a new request scope and grab\nanother scoped service instance, our scoped service container creates <em>another</em> scoped service for us, as our scoped\nservice lifetimes does <em>not</em> persist across application request scopes. Once our program ends, we do our usual cleaning\nup of our newly requested scoped services, but notice now that our singleton service is disposed of <em>after</em> our second\napplication \"request\" comes in and our application's life comes to end (harsh). Let's see what happens when we add\nanother transient service reference. Again, just below our last debug assertion:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Diagnostics</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> Microsoft</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Extensions</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">DependencyInjection</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> Program</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        static</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Main</span><span style=\"color:#666666\">(</span><span style=\"color:#4D9375\">string</span><span style=\"color:#666666\">[]</span><span style=\"color:#80A665\"> args</span><span style=\"color:#666666\">)</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Just below our Debug.Assert() line...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Create another transient service instance and compare it's object reference to the previous transient instances</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C99076\">\\n</span><span style=\"color:#C98A7D\">Grabbing a reference to another transient service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> anotherTransientService</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> secondScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">TransientService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Debug</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">Assert</span><span style=\"color:#666666\">(</span><span style=\"color:#BD976A\">anotherTransientService</span><span style=\"color:#CB7676\"> !=</span><span style=\"color:#BD976A\"> transientServiceOne</span><span style=\"color:#CB7676\"> &#x26;&#x26;</span><span style=\"color:#BD976A\"> anotherTransientService</span><span style=\"color:#CB7676\"> !=</span><span style=\"color:#BD976A\"> transientServiceTwo</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span></code></pre></figure>\n<p>And once again, running this code we get:</p>\n<pre><code>Building the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nConstructing a singleton service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\n\nBuilding our second service container...\n\nGrabbing a reference to another scoped service...\nConstructing a scoped service...\n\nGrabbing a reference to another transient service...\nConstructing a transient service...\nDisposing of transient service...\nDisposing of scoped service...\nDisposing of singleton service...\n</code></pre>\n<p>Focusing on the output after our second scoped application request, we see that as we request another transient service,\nour service container constructs yet <em>another</em> service instance for us, as transient services are instantiated each time\nthey're requested regardless of request scope. Once again, all of our request services from the second request scope are\ndisposed of as our application cleans up its resources. Lastly, let's add one more reference to our singleton service:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#121212;color:#dbd7caee\" tabindex=\"0\" data-language=\"csharp\" data-theme=\"vitesse-dark\"><code data-language=\"csharp\" data-theme=\"vitesse-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> System</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Diagnostics</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Services</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"><span style=\"color:#4D9375\">using</span><span style=\"color:#5DA994\"> Microsoft</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">Extensions</span><span style=\"color:#666666\">.</span><span style=\"color:#5DA994\">DependencyInjection</span><span style=\"color:#666666\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#CB7676\">namespace</span><span style=\"color:#5DA994\"> DependencyInjectionServiceLifetimes</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">{</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">    public</span><span style=\"color:#CB7676\"> class</span><span style=\"color:#5DA994\"> Program</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    {</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">        static</span><span style=\"color:#4D9375\"> void</span><span style=\"color:#80A665\"> Main</span><span style=\"color:#666666\">(</span><span style=\"color:#4D9375\">string</span><span style=\"color:#666666\">[]</span><span style=\"color:#80A665\"> args</span><span style=\"color:#666666\">)</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        {</span></span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Just below our Debug.Assert() line...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#758575DD\">            // Create another singleton service instance and compare it's object reference to the previous singleton instances</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Console</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">WriteLine</span><span style=\"color:#666666\">(</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#C99076\">\\n</span><span style=\"color:#C98A7D\">Grabbing a reference to another singleton service...</span><span style=\"color:#C98A7D99\">\"</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#CB7676\">            var</span><span style=\"color:#80A665\"> anotherSingletonService</span><span style=\"color:#666666\"> =</span><span style=\"color:#BD976A\"> secondScopedContainer</span><span style=\"color:#666666\">.</span><span style=\"color:#BD976A\">ServiceProvider</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">GetRequiredService</span><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#5DA994\">SingletonService</span><span style=\"color:#666666\">>();</span></span>\n<span data-line=\"\"><span style=\"color:#BD976A\">            Debug</span><span style=\"color:#666666\">.</span><span style=\"color:#80A665\">Assert</span><span style=\"color:#666666\">(</span><span style=\"color:#BD976A\">anotherSingletonService</span><span style=\"color:#CB7676\"> ==</span><span style=\"color:#BD976A\"> singletonServiceOne</span><span style=\"color:#CB7676\"> &#x26;&#x26;</span><span style=\"color:#BD976A\"> anotherSingletonService</span><span style=\"color:#CB7676\"> ==</span><span style=\"color:#BD976A\"> singletonServiceTwo</span><span style=\"color:#666666\">);</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">    }</span></span>\n<span data-line=\"\"><span style=\"color:#666666\">}</span></span></code></pre></figure>\n<p>Once again running this code, we get:</p>\n<pre><code>Building the first service container...\n\nConstructing a scoped service...\nConstructing a transient service...\nConstructing a transient service...\nConstructing a singleton service...\nDisposing of transient service...\nDisposing of transient service...\nDisposing of scoped service...\n\nBuilding our second service container...\n\nGrabbing a reference to another scoped service...\nConstructing a scoped service...\n\nGrabbing a reference to another transient service...\nConstructing a transient service...\n\nGrabbing a reference to another singleton service...\nDisposing of transient service...\nDisposing of scoped service...\nDisposing of singleton service...\n</code></pre>\n<p>Again focusing on the output after we create another request scope, we see that even across requests, when we reference\na singleton service from our container, we get the same reference back from the first time it was constructed within the\nscope of our first request. Remember that singletons are created only <em>once</em> per application lifetime, so we don't see\nthe call to the constructor once we request it once again from our second request scope. Nothing new with our resource\ncleanup either.</p>\n<h2>Wrapping up</h2>\n<p>Another day, another service lifetime explored. We've seen how different service lifetimes construct themselves at\nrequest time and are cleaned up by their respective resource manager. When registering service lifetimes, we have to put\nsome thought into what kind of lifetime scope it should. Would you want a service that utilizes <code>IDbConnection</code> to be a\nsingleton? Probably not, as you might have a few angry customers on your hands. After today, I know I'll be a little\nmore conscious about the lifetimes I choose.</p>\n<p>Until next time, amigos!</p>"
  },
  "_id": "2020/service-lifetimes-in-plain-english.md",
  "_raw": {
    "sourceFilePath": "2020/service-lifetimes-in-plain-english.md",
    "sourceFileName": "service-lifetimes-in-plain-english.md",
    "sourceFileDir": "2020",
    "contentType": "markdown",
    "flattenedPath": "2020/service-lifetimes-in-plain-english"
  },
  "type": "Post",
  "url": "/blog/2020/service-lifetimes-in-plain-english"
}