{
  "title": "Migrating to Astro",
  "description": "Astro, Svelte, and Rust walk into a bar...",
  "pubDate": "2023-03-15T07:00:00.000Z",
  "category": "astro",
  "heroImage": "/images/migrating-to-astro/astro_meme.jpg",
  "draft": false,
  "keywords": [
    "astro",
    "content"
  ],
  "body": {
    "raw": "\nDuring a recent quarter (third?) life crisis, I decided to do what every developer does when they need something to work\non - I rewrote my blog from the ground up. I consider rebuilding personal blogs/portfolios a right of passage and have\nso far been able to squeeze a rewrite out about once every two years.\n\nAre the rewrites ever justified? No.\n\nWere the previous iterations functional enough for my needs? Yes.\n\nAm I eventually going to rewrite it again in a few years? Probably.\n\n## Diminishing focus on content\n\nMy previous portfolio/blog was written with [next.js](https://nextjs.org) and while it satisfied all my developer needs\nto produce content, write posts, etc. I wanted to go back to the drawing board as I find I was focusing more on\nframework detail concerns rather than what my blog was intended to be - a resource for developer content. I was quickly\nlosing sight of writing new content regularly and was seeking a return to basics.\n\n## Astro to the rescue\n\nEnter [astro](https://astro.build/), a web framework focused on content rather than framework internals. With astro, the\nfocus is on shipping the minimal amount of JS to the client for blazingly fast<sup>tm</sup> static websites. My blog is\nnothing more than static content, and astro seemed like the perfect choice with the icing on the cake being their\nrecently shipped [content collections](https://docs.astro.build/en/guides/content-collections/) allowing developers to\nwrite type-safe markdown content.\n\nWhat's even better about astro are the\nvarious [UI integrations](https://docs.astro.build/en/core-concepts/framework-components/) that users can plug and play\nfor when rich interactivity is needed. Better yet, astro allows for full control of _how_ the interactive framework\ncomponents should be shipped to the client. This leads us to the concept\nof [component islands](https://jasonformat.com/islands-architecture/), or rich interactive sections of a web page that\nare individualistic from their static peers. Astro was built on\nthe [concept of islands](https://docs.astro.build/en/concepts/islands/), allowing users to bring in interactive JS\n_without_ affecting the rest of the page.\n\nWhat this leads to, in practice, is being able to selectively choose bits of the page to be interactive (i.e. require\nJS) without holding up the rendering of the rest of the page. Astro components are isolated from one another, in this\nsense, and default to statically rendered HTML which means _wicked_ fast page loading.\n\nThis ultimately allowed me to build a primarily static site with content in markdown (this blog you're reading, for\nexample) while giving me the ability to bring in my JS framework of choice in [Svelte](https://svelte.dev/) for \"micro\"\ncomponents. I refer to the integration components as \"micro\" as they're simply a rendered subset of the entire static\nsite - we're not working within the context of a full-blown Svelte web application.\n\n## Statically dynamic\n\nInevitably, I hit a point where rich interactivity was needed to interact with the Spotify API, adding a bit of flare to\nmy site in the form of a widget to display whatever song/podcast I might be listening to at the moment (shout out\nto [Lee Robinson](https://leerob.io/), he had this on a previous version of his site). Since astro is meant for\nprimarily content-driven static websites, the SSG that astro runs pulls in all the necessary data at build time, which\nmeant the calls to the Spotify API were snapshots of whatever I had happened to be listening to at build time rather\nthan in real-time.\n\nWhile there were multiple ways to attack the problem of providing rich interactivity and real-time Spotify data, I went\nwith Svelte to build out a small widget that simply retrieved data from Spotify on page load. The only issue I had with\nthis approach was exposing my Spotify refresh token for authentication and my hashed client credentials (not a _huge_\nissue, but one could use the hash to retrieve access tokens).\n\n## Keeping things secure\n\n_In theory_, anyone could simply open a dev tools window and inspect the outbound requests to Spotify, grab my token,\nand start making requests to Spotify on my behalf - not great, as I'd eventually hit a quota/threshold in the number of\ncalls in this scenario if this were to happen. While not a _huge deal_ as the song/podcast I'm currently listening to\nisn't exactly top-secret security clearance level information, I didn't want to have to deal with swapping my client\ncredentials and rotating my refresh token regularly.\n\nThe solution?\n\nMove the Spotify API interaction behind a serverless function. This approach allowed me to hide my credentials on the\nserver without risk of exposure and simplifies the data fetching components on the frontend, as they're simply just\nretrieving the most basic information they need to display the Spotify widget without having to sift through giant JSON\nresponses to pull out the necessary data each time a page is loaded on my site.\n\n## Simply serverless\n\nSince I host using [Vercel](https://vercel.com/), the most obvious solution was to use edge functions... but where's the\nfun in that? I write JS/TS all the time, and quite frankly, I was ready for a change of pace.\n\nAnother option was\nto [enable SSR](https://docs.astro.build/en/guides/server-side-rendering/#enabling-ssr-in-your-project) with astro, but\nthen I lose the benefits of SSG. Astro's SSR also requires an adapter to the hosting platform to be installed and\nconfigured, and while not a painful task to do by any means, it would require a bit of lifting and shifting if I woke up\ntomorrow and decided to deploy to [Cloudflare Pages](https://pages.cloudflare.com/) instead of Vercel.\n\nI've been looking for an excuse to write as much [Rust](https://www.rust-lang.org/) as humanly possible in my day-to-day\ndeveloper tasks, and this was the perfect opportunity to use it.\n\nSo, I had a few options. I could write my own Rust web server and host it\non [fly.io](https://fly.io/), [DigitalOcean](https://www.digitalocean.com/), etc. but that would have required me to\nmanage the infrastructure a bit more closely than I would have cared for. There's also a Rust runtime\nfor [AWS lambda functions](https://docs.aws.amazon.com/sdk-for-rust/latest/dg/lambda.html), but again, this would\nrequire more AWS infrastructure management from me for such a simple use case.\n\n## If _can_ be written in Rust, it _will_ written Rust\n\nEnter [shuttle](https://shuttle.rs/), a relatively new platform providing users the ability to write serverless Rust\nfunctions and simply deploy on their infrastructure - little to no management on my end, fully capable of doing anything\nyou want in Rust. Perfect!\n\nAt the end of the day, I'm not exactly writing mission-critical production code - I just need data from Spotify.\n\nBut... I don't want to use JS/TS.\n\nAnd I don't want to want to fall back into SSR as I'll miss out on some nice benefits of SSG.\n\nAnd I want to write Rust.\n\nSo let's do all of that.\n\n## Many hours later\n\nFast-forward some time, and with the help of shuttle, I was able to spin up a mighty\nsmall [axum](https://docs.rs/axum/latest/axum/) server with a single route to call out to Spotify, get some data, and\nmarshal it into a simple response for the frontend end all while securely keeping my credentials and refresh token\nhidden from the outside world.\n\nWhen a page on my site loads, astro sends the necessary JS to render the Svelte Spotify widget (as you can see in the\nfooter), and once loaded the component calls out to my serverless Rust function. Neat!\n\nFor the curious, all of the serverless Rust code can be\nfound [here](https://github.com/JoeyMckenzie/joey-mckenzie-tech/tree/main/src/serverless) in the same repository that\nhosts this blog.\n\n## Wrapping up\n\nProject rewrites can be fun, allowing for the exploration of new technologies and language ecosystems as I'm sure we've\nall seen at one point or another during a company migration of existing services onto the latest shiny thing in the dev\nworld.\n\nYou can find all the source code of my most recent portfolio iteration on\nmy [GitHub](https://github.com/JoeyMckenzie/joey-mckenzie-tech) - feel free to fork your version!\n",
    "html": "<p>During a recent quarter (third?) life crisis, I decided to do what every developer does when they need something to work\non - I rewrote my blog from the ground up. I consider rebuilding personal blogs/portfolios a right of passage and have\nso far been able to squeeze a rewrite out about once every two years.</p>\n<p>Are the rewrites ever justified? No.</p>\n<p>Were the previous iterations functional enough for my needs? Yes.</p>\n<p>Am I eventually going to rewrite it again in a few years? Probably.</p>\n<h2>Diminishing focus on content</h2>\n<p>My previous portfolio/blog was written with <a href=\"https://nextjs.org\">next.js</a> and while it satisfied all my developer needs\nto produce content, write posts, etc. I wanted to go back to the drawing board as I find I was focusing more on\nframework detail concerns rather than what my blog was intended to be - a resource for developer content. I was quickly\nlosing sight of writing new content regularly and was seeking a return to basics.</p>\n<h2>Astro to the rescue</h2>\n<p>Enter <a href=\"https://astro.build/\">astro</a>, a web framework focused on content rather than framework internals. With astro, the\nfocus is on shipping the minimal amount of JS to the client for blazingly fasttm static websites. My blog is\nnothing more than static content, and astro seemed like the perfect choice with the icing on the cake being their\nrecently shipped <a href=\"https://docs.astro.build/en/guides/content-collections/\">content collections</a> allowing developers to\nwrite type-safe markdown content.</p>\n<p>What's even better about astro are the\nvarious <a href=\"https://docs.astro.build/en/core-concepts/framework-components/\">UI integrations</a> that users can plug and play\nfor when rich interactivity is needed. Better yet, astro allows for full control of <em>how</em> the interactive framework\ncomponents should be shipped to the client. This leads us to the concept\nof <a href=\"https://jasonformat.com/islands-architecture/\">component islands</a>, or rich interactive sections of a web page that\nare individualistic from their static peers. Astro was built on\nthe <a href=\"https://docs.astro.build/en/concepts/islands/\">concept of islands</a>, allowing users to bring in interactive JS\n<em>without</em> affecting the rest of the page.</p>\n<p>What this leads to, in practice, is being able to selectively choose bits of the page to be interactive (i.e. require\nJS) without holding up the rendering of the rest of the page. Astro components are isolated from one another, in this\nsense, and default to statically rendered HTML which means <em>wicked</em> fast page loading.</p>\n<p>This ultimately allowed me to build a primarily static site with content in markdown (this blog you're reading, for\nexample) while giving me the ability to bring in my JS framework of choice in <a href=\"https://svelte.dev/\">Svelte</a> for \"micro\"\ncomponents. I refer to the integration components as \"micro\" as they're simply a rendered subset of the entire static\nsite - we're not working within the context of a full-blown Svelte web application.</p>\n<h2>Statically dynamic</h2>\n<p>Inevitably, I hit a point where rich interactivity was needed to interact with the Spotify API, adding a bit of flare to\nmy site in the form of a widget to display whatever song/podcast I might be listening to at the moment (shout out\nto <a href=\"https://leerob.io/\">Lee Robinson</a>, he had this on a previous version of his site). Since astro is meant for\nprimarily content-driven static websites, the SSG that astro runs pulls in all the necessary data at build time, which\nmeant the calls to the Spotify API were snapshots of whatever I had happened to be listening to at build time rather\nthan in real-time.</p>\n<p>While there were multiple ways to attack the problem of providing rich interactivity and real-time Spotify data, I went\nwith Svelte to build out a small widget that simply retrieved data from Spotify on page load. The only issue I had with\nthis approach was exposing my Spotify refresh token for authentication and my hashed client credentials (not a <em>huge</em>\nissue, but one could use the hash to retrieve access tokens).</p>\n<h2>Keeping things secure</h2>\n<p><em>In theory</em>, anyone could simply open a dev tools window and inspect the outbound requests to Spotify, grab my token,\nand start making requests to Spotify on my behalf - not great, as I'd eventually hit a quota/threshold in the number of\ncalls in this scenario if this were to happen. While not a <em>huge deal</em> as the song/podcast I'm currently listening to\nisn't exactly top-secret security clearance level information, I didn't want to have to deal with swapping my client\ncredentials and rotating my refresh token regularly.</p>\n<p>The solution?</p>\n<p>Move the Spotify API interaction behind a serverless function. This approach allowed me to hide my credentials on the\nserver without risk of exposure and simplifies the data fetching components on the frontend, as they're simply just\nretrieving the most basic information they need to display the Spotify widget without having to sift through giant JSON\nresponses to pull out the necessary data each time a page is loaded on my site.</p>\n<h2>Simply serverless</h2>\n<p>Since I host using <a href=\"https://vercel.com/\">Vercel</a>, the most obvious solution was to use edge functions... but where's the\nfun in that? I write JS/TS all the time, and quite frankly, I was ready for a change of pace.</p>\n<p>Another option was\nto <a href=\"https://docs.astro.build/en/guides/server-side-rendering/#enabling-ssr-in-your-project\">enable SSR</a> with astro, but\nthen I lose the benefits of SSG. Astro's SSR also requires an adapter to the hosting platform to be installed and\nconfigured, and while not a painful task to do by any means, it would require a bit of lifting and shifting if I woke up\ntomorrow and decided to deploy to <a href=\"https://pages.cloudflare.com/\">Cloudflare Pages</a> instead of Vercel.</p>\n<p>I've been looking for an excuse to write as much <a href=\"https://www.rust-lang.org/\">Rust</a> as humanly possible in my day-to-day\ndeveloper tasks, and this was the perfect opportunity to use it.</p>\n<p>So, I had a few options. I could write my own Rust web server and host it\non <a href=\"https://fly.io/\">fly.io</a>, <a href=\"https://www.digitalocean.com/\">DigitalOcean</a>, etc. but that would have required me to\nmanage the infrastructure a bit more closely than I would have cared for. There's also a Rust runtime\nfor <a href=\"https://docs.aws.amazon.com/sdk-for-rust/latest/dg/lambda.html\">AWS lambda functions</a>, but again, this would\nrequire more AWS infrastructure management from me for such a simple use case.</p>\n<h2>If <em>can</em> be written in Rust, it <em>will</em> written Rust</h2>\n<p>Enter <a href=\"https://shuttle.rs/\">shuttle</a>, a relatively new platform providing users the ability to write serverless Rust\nfunctions and simply deploy on their infrastructure - little to no management on my end, fully capable of doing anything\nyou want in Rust. Perfect!</p>\n<p>At the end of the day, I'm not exactly writing mission-critical production code - I just need data from Spotify.</p>\n<p>But... I don't want to use JS/TS.</p>\n<p>And I don't want to want to fall back into SSR as I'll miss out on some nice benefits of SSG.</p>\n<p>And I want to write Rust.</p>\n<p>So let's do all of that.</p>\n<h2>Many hours later</h2>\n<p>Fast-forward some time, and with the help of shuttle, I was able to spin up a mighty\nsmall <a href=\"https://docs.rs/axum/latest/axum/\">axum</a> server with a single route to call out to Spotify, get some data, and\nmarshal it into a simple response for the frontend end all while securely keeping my credentials and refresh token\nhidden from the outside world.</p>\n<p>When a page on my site loads, astro sends the necessary JS to render the Svelte Spotify widget (as you can see in the\nfooter), and once loaded the component calls out to my serverless Rust function. Neat!</p>\n<p>For the curious, all of the serverless Rust code can be\nfound <a href=\"https://github.com/JoeyMckenzie/joey-mckenzie-tech/tree/main/src/serverless\">here</a> in the same repository that\nhosts this blog.</p>\n<h2>Wrapping up</h2>\n<p>Project rewrites can be fun, allowing for the exploration of new technologies and language ecosystems as I'm sure we've\nall seen at one point or another during a company migration of existing services onto the latest shiny thing in the dev\nworld.</p>\n<p>You can find all the source code of my most recent portfolio iteration on\nmy <a href=\"https://github.com/JoeyMckenzie/joey-mckenzie-tech\">GitHub</a> - feel free to fork your version!</p>"
  },
  "_id": "2023/migrating-to-astro.md",
  "_raw": {
    "sourceFilePath": "2023/migrating-to-astro.md",
    "sourceFileName": "migrating-to-astro.md",
    "sourceFileDir": "2023",
    "contentType": "markdown",
    "flattenedPath": "2023/migrating-to-astro"
  },
  "type": "Post",
  "url": "/blog/2023/migrating-to-astro"
}