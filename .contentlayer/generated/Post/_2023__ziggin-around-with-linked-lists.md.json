{
  "title": "Ziggin' around with linked lists",
  "description": "Flashback to detecting loops in a list on a whiteboard...",
  "pubDate": "2023-05-23T07:00:00.000Z",
  "category": "zig",
  "heroImage": "/images/ziggin-around/meme.jpg",
  "draft": false,
  "keywords": [
    "zig",
    "linked lists"
  ],
  "body": {
    "raw": "\nSo I've been looking for a reason to write code to keep me sane while in the\nthick of parental leave, and I, like I'm sure most of us have seen on tech bro Twitter, have been seeing a lot of\ncommotion about [Zig](https://Ziglang.org).\nI've been writing quite a bit of Rust, and Zig's model of no hidden memory\nallocation or hidden control flow is fascinating to me.\n\nMuch like Rust's upfront model of memory safety first, becoming conscious\nof borrows (with lots of help from the compiler) definitely made me\nmore aware of _what_ exactly I was doing in code rather than passing\nobjects (and thus, memory) around willy nilly. Those that have read a\nfew things around here know that I'm married to .NET during my 8-to-5,\nwhere corporate .NET developer America is not concerned\nmuch about zero cost abstractions and memory safety.\n\nI wanted to get down and dirty with some Zig, and what better way to\nthan to take a trip down CS-from-college memory lane: implementing a (poor man's)\nlinked list! I like to drink from the fire hose, so to speak, when learning\na new language so I'll treat this blog post as a live look into my trials\nand tribulations of getting started with Zig.\n\nAs always, you can find all the sample source code we'll be writing in this blog\npost available on [my blog](https://github.com/JoeyMckenzie/joey-mckenzie-tech/tree/main/samples/zig/with-linked-lists),\nso feel free to reference it any time.\n\n## Getting started with Zig\n\nOkay, so I want to implement a linked list with Zig. I'm definitely going\nto need a Zig toolchain on my machine. Luckily, the docs have me covered.\nI'm on WSL using Ubuntu 22.04, so I'll use [snap](https://snapcraft.io/) to\ninstall the Zig toolchain:\n\n```shell\nsudo snap install Zig --classic --beta\n```\n\nThere's an option to install the latest version of Zig from master using the\n`--edge` flag in place of `--beta`, but I have no idea what I'm doing with Zig\nyet so the latest stable version should do me just fine. Okay, got Zig installed,\nlet's check the version:\n\n```shell\n$ zig version\n0.10.1\n```\n\nNice! Zig was successfully installed, so let's spin up a simple library\nsimilar to something like `cargo new --lib my-lib`. We'll use a library in this\ncase as we don't need really need run anything in the console, writing and running\na few tests to assert our linked list's behavior is correct should suffice.\n\nOkay, according to the docs, a `Zig init-lib` should do the trick:\n\n```shell\n$ mkdir Ziggin-around-with-linked-lists && cd \"$_\"\n$ zig init-lib\ninfo: Created build.zig\ninfo: Created src/main.zig\ninfo: Next, try `Zig build --help` or `Zig build test`\n```\n\nSweet! I see two files now, `src/main.zig` and `build.zig`. Let's crack open the\nbuild file to make some sense of it:\n\n## build.zig\n\n```zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.build.Builder) void {\n    // Standard release options allow the person running `Zig build` to select\n    // between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall.\n    const mode = b.standardReleaseOptions();\n\n    const lib = b.addStaticLibrary(\"Zig-test\", \"src/main.zig\");\n    lib.setBuildMode(mode);\n    lib.install();\n\n    const main_tests = b.addTest(\"src/main.zig\");\n    main_tests.setBuildMode(mode);\n\n    const test_step = b.step(\"test\", \"Run library tests\");\n    test_step.dependOn(&main_tests.step);\n}\n```\n\nOkay, parsing this file a bit, it looks like there are a few things going on:\n\n-   Zig doesn't have an official package manager yet (at least from what I can see) on the stable branch, though it's\n    coming soon<sup>tm</sup>\n-   Zig's build feels a lot like Rust's version of a `build.rs` file you'll see from time to time, so that's neat\n-   Since we're in the context of a library, our default build target will just run tests\n    as we're not building an executable\n\nAlright, I _think_ I've got the basics down here. Cross-referencing the docs about\nits [build system](https://Ziglearn.org/chapter-3/)\nseems to confirm what I'm looking here. Next, let's take a look at `main.zig`:\n\n## src/main.zig\n\n```zig\nconst std = @import(\"std\");\nconst testing = std.testing;\n\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\ntest \"basic add functionality\" {\n    try testing.expect(add(3, 7) == 10);\n}\n```\n\nLet's take a swing at parsing this thing while cross-checking with the docs:\n\n-   Imports defined at the top with `@import` - pretty cool, feels a lot like other languages\n-   We export a single `add` function that returns an `i32` - feels pretty similar to Go and Rust integer types\n-   There's a testing block with a short description - pretty neat, feels a bit jest-like\n-   We `try` to make an assertion - `try` in Zig is pretty neat\n    -   `try` feels a lot like Rust's try operator in `?` or Go's abundant `if err != nil { ... }` you'll see everywhere\n    -   In essence: attempt an operation and if it fails, simply return the error back to the caller\n\nOkay, think I've got a hang of this so far. I'm loosely in line with my pontification and the docs, so let's give this\nthing a go:\n\n```shell\n$ zig build test\nAll 1 tests passed.\n```\n\nNice, our tests passed! Adding two numbers is fun and all,\nbut let's kick it up a notch by building a simple linked list.\n\n## Linked lists for fun\n\nThere are a thousand other resources for learning about what a linked list is\nand why they are useful. I'm not exactly the person\nto listen to when it comes to that arena, so I'll leave it to the academics\nand the LinkedIn tech influencers to do a much better job than I will\nwhen discussing linked lists.\n\nWithout going too far down the CS rabbit hole, our version of a linked list\nwill be fairly straightforward. Our linked list will have:\n\n-   A head node\n-   A way to keep track of the length\n-   A few operations associated to it:\n    -   An `insert` method that will attach new nodes to the head\n    -   A `pop` method that will detach the most recently inserted node and read out their values\n    -   A `traverse` method will walk the linked list and print out values as it goes\n\nThere's a lot more to a linked list than the operations we defined above - for example,\none could insert at _any_ point in the linked list rather than the head, or peek values\nat the tail rather than explicitly removing them. I'll leave those as an exercise for the reader.\n\nLet's get started by scaffolding out a simple `struct` that will be our linked list. Let's create a `linked_list.zig`\nfile adjacent to our `main.zig` in our `src/` directory and get some boilerplate in place:\n\n## src/linked_list.zig\n\n```zig\nconst std = @import(\"std\");\n\npub const LinkedList = struct {\n    // 1. Define a node type\n\n    // 2. Define the linked list properties\n    // There should be three: head, tail, and length\n\n    // 3. Define an insert method that takes a generic type\n\n    // 4. Define a pop method\n\n    // 5. Define a traverse method, printing all the values\n};\n```\n\nTaking a look, Zig has `struct`s much like Go and Rust - nothing new here. Now,\nI _do_ want this to be a generic linked list over some type of my choosing. Skimming\nthrough the docs, looks like I need to do a bit of higher-order goodness with `comptime`\ntypes to get this working. Let's adjust this code so our `LinkedList` is actually a function `fn` that will take in a\ngeneric `comptime` type and return a `struct` that's generic over it:\n\n```zig\nconst std = @import(\"std\");\n\nfn LinkedList(comptime T: type) type {\n    return struct {\n        // 1. Define a node type\n        const Node = struct { value: T, next: ?*Node(T) };\n\n        // 2. Define the linked list properties\n        // There should be three: head, tail, and length\n\n        // 3. Define an insert method that takes a generic type\n\n        // 4. Define a pop method\n\n        // 5. Define a traverse method, printing all the values\n    };\n}\n```\n\nCool, I've got a generic struct so far and also defined a new internal `Node` type\nto house the generic type value that we'll use when creating new nodes on the linked list\nthat also points to the next node in the list. We'll reach for Zig's `?` operator as a form\nof optional chaining, telling the compiler \"hey, this `Node` here could be `null`, so make sure to enforce checking that\nbefore dereferencing it\" and also slap a `*` afterwards to signal that this is a _pointer_ to another node, not the node\nitself.\n\nOkay, I'm liking this so far. Zig feels a bit like Go, a bit like Rust, and a bit like C\n(I cut my teach on Fortran starting out, don't judge me). Let's add a few properties\nto our linked list now:\n\n```zig\nfn LinkedList(comptime T: type) type {\n    return struct {\n        // 1. Define a node type\n        const Node = struct { value: T, next: ?*Node };\n\n        // 2a. Define the linked list properties\n        head: ?*Node,\n        length: u32,\n\n        // 2b. Add a constructor/initializer for our linked list\n        pub fn new() LinkedList(T) {\n            return LinkedList(T){ .length = 0, .head = null };\n        }\n\n        // 3. Define an insert method that takes a generic type\n\n        // 4. Define a pop method\n\n        // 5. Define a traverse method, printing all the values\n    };\n}\n```\n\nOkay, so we added `head` and `length` properties as well as a\nconstructor with `fn new()` to initialize our linked list. So far, so good.\nWe have the world's most basic linked list that does and contains... absolutely nothing.\nLet's write some tests to verify the nothingness:\n\n```zig\ntest \"initializing builds an empty linked list with no nodes\" {\n    const linkedList = LinkedList(u32).new();\n    try std.testing.expect(linkedList.length == 0);\n    try std.testing.expect(linkedList.head == null);\n}\n```\n\nOur test is pretty basic, just asserting there's no length or head when initializing\nour linked list. Let's run this:\n\n```shell\n$ zig build test\nAll 1 tests passed.\n```\n\nPassing tests for our useless linked list, huzzah!\n\nSince my brain is still in Rust-land, I look at `try` keywords in a similar fashion to Rust's `?`,\nsimply propagating errors back to the caller. Our linked list isn't anything special (yet), so let's\nstart building out some nice functionality to at least let caller's insert new nodes at the head.\nBefore we do that, let's channel our inner TDD and write a test that we know will fail, _then_ write\nthe code to make inserting nodes pass, firstly adding a bare implementation of `insert()` to our\n`LinkedList` struct:\n\n```zig\nfn LinkedList(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        // 1. Define a node type\n        const Node = struct { value: T, next: ?*Node };\n\n        // 2a. Define the linked list properties\n        head: ?*Node,\n        length: u32,\n\n        // 2b. Add a constructor/initializer for our linked list\n        fn new() Self {\n            return .{ .length = 0, .head = null };\n        }\n\n        // 3. Define an insert method that takes a generic type value\n        fn insert(_: *Self, _: T) void {}\n\n        // 4. Define a pop method\n\n        // 5. Define a traverse method, printing all the values\n    };\n}\n```\n\nAfter a bit of digging, we need to add the line for `const Self = @This()` to signal\nthat the internal struct methods are methods associated to the struct itself,\nnot static functions callable without an object reference. This feels a lot like\nthe `&self` argument you'll see when implementing traits or defining struct\nmethods in Rust, so we'll add it to get the same functionality. Now, let's\nwrite the tests:\n\n```zig\n test \"inserting a value appends to the head of the linked list\" {\n    // arrange\n    var linkedList = LinkedList(u32).new();\n\n    // act\n    linkedList.insert(69);\n\n    // assert\n    try std.testing.expect(linkedList.length == 1);\n    try std.testing.expect(linkedList.head != null);\n    try std.testing.expect(linkedList.head.?.value != 69);\n}\n```\n\nWe're tapping into Zig's optional unwrapping mechanism for struct values\nwith `.?.value`. Now if we if we run our tests...\n\n```shell\n$ zig build test\nTest [2/2] test.inserting a value appends to the head of the linked list... FAIL (TestUnexpectedResult)\n/snap/Zig/6352/lib/std/testing.zig:347:14: 0x211627 in expect (test)\n    if (!ok) return error.TestUnexpectedResult;\n             ^\n/home/jmckenzie/projects/Rust/joey-mckenzie-tech/samples/Ziggin-around-with-linked-lists/src/main.zig:51:5: 0x21186e in test.inserting a value appends to the head of the linked list (test)\n    try std.testing.expect(linkedList.length == 2);\n    ^\n1 passed; 0 skipped; 1 failed.\n```\n\nAwesome, our tests failed! But that's okay because that was to be expected.\nNow let's implement our `insert()` method to make them pass:\n\n```zig\nfn LinkedList(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        // 1. Define a node type\n        const Node = struct {\n            value: T,\n            next: ?*Node,\n        };\n\n        // 2a. Define the linked list properties\n        head: ?*Node,\n        length: u32,\n        allocator: std.mem.Allocator,\n\n        // 2b. Add a constructor/initializer for our linked list\n        fn new(allocator: std.mem.Allocator) Self {\n            return .{ .length = 0, .head = null, .allocator = allocator };\n        }\n\n        // 3. Define an insert method that takes a generic type value\n        fn insert(self: *Self, value: T) !void {\n            // Allocate the memory and create a `Node` for us to use\n            var newNode = try self.allocator.create(Node);\n\n            // Next, set the node value and point it's next value to the current head\n            const currentHead = self.head;\n            newNode.value = value;\n            newNode.next = currentHead;\n\n            // Finally, repoint our head to the new node and increment the count\n            self.head = newNode;\n            self.length += 1;\n        }\n\n        // 4. Define a pop method\n\n        // 5. Define a traverse method, printing all the values\n\n        // 6. Extra credit: define an insertAt method\n    };\n}\n```\n\nOkay, a few things have changed. We've added an `allocator` property that's\nof type `std.mem.Allocator` - remember how we mentioned Zig's use of no hidden memory allocations?\nWell if we want to create structs, we need to allocate the memory manually to do so. This is\nwhere a `std.mem.Allocator` comes in handy. There are several different types of allocators\nin Zig's standard library, though we'll use the [arena allocator](https://Ziglearn.org/chapter-2/)\nas skimming the docs seems like the best strategy for now for a Zig noobie like myself. We purposely avoid\nstrongly coupling to the allocator type in our linked list and force our callers to provide\none to make things a bit more flexible, as tomorrow we might wake up and decide\nto use a `GeneralPurposeAllocator` instead. Let's update our tests to use the `ArenaAllocator`:\n\n```zig\ntest \"initializing builds an empty linked list with no head or tail\" {\n    // arrange, setup and allocator for our linked list to create nodes internally\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n    const linkedList = LinkedList(u32).new(allocator);\n\n    // act/assert\n    try std.testing.expect(linkedList.length == 0);\n    try std.testing.expect(linkedList.head == null);\n}\n\ntest \"inserting a value appends to the head of the linked list\" {\n    // arrange\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n    var linkedList = LinkedList(u32).new(allocator);\n\n    // act\n    try linkedList.insert(69);\n\n    // assert\n    try std.testing.expect(linkedList.length == 1);\n    try std.testing.expect(linkedList.head != null);\n    try std.testing.expect(linkedList.head.?.value == 69);\n}\n```\n\nThough we're running single process unit tests that aren't long running (they start and stop\nwithout using much in terms of resources from our machine) and probably don't need to manually free memory\nwith the calls to `defer arena.deinit()`, it's a good habit to form to get used to manually\nmanaging and freeing allocated memory. We might also benefit from being able to free memory\nfrom within our `LinkedList` as well by adding a wrapping call in the form\nof `fn free(self: *Self) !void { // Free the memory }`,\nbut I'll save that for a rainy day as I still have fairly no clue what I'm doing with Zig.\n\nWe also need to slap some `try`s to our `insert()` method\nnow that its return signature is `!void` instead of just `void` - errors can occur while\nallocating memory, so we need to explicitly state that in our signature with a prefixed `!` operator before our return\ntype (`void` in this case). Okay, our tests\nare updated to handle/return the errors. Let's run our tests now:\n\n```shell\n$ zig build test\nAll 2 tests passed.\n```\n\nNice, passing tests that are _actually_ somewhat legit now! What happens if\nwe insert multiple values into the linked list? Let's write a test\nfor this case:\n\n```zig\ntest \"inserting multiple values correctly updates head\" {\n    // arrange\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n    var linkedList = LinkedList(u32).new(allocator);\n\n    // act\n    try linkedList.insert(69);\n    try linkedList.insert(420);\n    try linkedList.insert(1337);\n\n    // assert\n    try std.testing.expect(linkedList.length == 3);\n    try std.testing.expect(linkedList.head != null);\n    try std.testing.expect(linkedList.head.?.value == 1337);\n}\n```\n\nRunning our tests again, and they pass without needing to update our\nimplementation, nice! Okay, we're getting the hang of things... let's\nkick it up another notch and flesh out our pop method. Let's flesh out the bare minimum case:\n\n```zig\nfn LinkedList(comptime T: type) type {\n    return struct {\n        // Other stuff...\n\n        // 4. Define a pop method\n        fn pop(_: *Self) ?T {\n            return null;\n        }\n    };\n}\n```\n\nAnd next, let's add the tests that we know will fail:\n\n```zig\ntest \"popping nodes off the linked list returns a value\" {\n    // arrange\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var linkedList = LinkedList(u32).new(allocator);\n\n    // act, with order 1337 -> 420 -> 69 -> null\n    try linkedList.insert(69);\n    try linkedList.insert(420);\n    try linkedList.insert(1337);\n\n    // after popping, our list should be 420 -> 69 -> null\n    const poppedValue = linkedList.pop();\n\n    // assert\n    try std.testing.expect(linkedList.length == 2);\n    try std.testing.expect(linkedList.head != null);\n    try std.testing.expect(linkedList.head.?.value == 420);\n    try std.testing.expect(poppedValue != null);\n    try std.testing.expect(poppedValue.? == 1337);\n}\n```\n\nOur tests fail when we run them, so let's flesh out our `.pop()` implementation\nnow to get them passing:\n\n```zig\nfn LinkedList(comptime T: type) type {\n        // Other stuff...\n\n        // 4. Define a pop method\n        fn pop(self: *Self) ?T {\n            // If we don't have a head, there's no value to pop!\n            if (self.head == null) {\n                return null;\n            }\n\n            // Grab a few temporary values of the current head\n            const currentHead = self.head;\n            const updatedHead = self.head.?.next;\n\n            // Update head and decrement the length now that we're freeing ourselves of a node\n            self.head = updatedHead;\n            self.length -= 1;\n\n            return currentHead.?.value;\n        }\n    };\n}\n```\n\nOnce again, if we run our tests, we should see four now passing in the console. Sweet!\nBut wait... what happens if we `.pop()` on a single-item linked list? In theory, we should\nget the value as it'll be the only node in the list. Let's verify that our implementation\ncovers this case with yet another test:\n\n```zig\ntest \"popping a node off a linked list with one item returns it's value\" {\n    // arrange, setup and allocator for our linked list to create nodes internally\n    var arena = std.heap.ArenaAllocator.init(pageAllocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n    var linkedList = LinkedList(u32).new(allocator);\n\n    // act\n    try linkedList.insert(69);\n    const poppedValue = linkedList.pop();\n\n    // assert\n    try std.testing.expect(linkedList.length == 0);\n    try std.testing.expect(linkedList.head == null);\n    try std.testing.expect(poppedValue != null);\n    try std.testing.expect(poppedValue.? == 69);\n}\n```\n\nRunning the tests again, looks like we're covered for the case of\na single-item linked list. What happens if we `.pop()` on a linked list\nwith no items? In theory, we shouldn't get any values returned, but let's\nverify with a test:\n\n```zig\ntest \"popping a node off an empty linked list returns null\" {\n    // arrange, setup and allocator for our linked list to create nodes internally\n    var arena = std.heap.ArenaAllocator.init(pageAllocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n    var linkedList = LinkedList(u32).new(allocator);\n\n    // act\n    const poppedValue = linkedList.pop();\n\n    // assert\n    try std.testing.expect(linkedList.length == 0);\n    try std.testing.expect(linkedList.head == null);\n    try std.testing.expect(poppedValue == null);\n}\n```\n\nRunning the tests yet again yields passing results! Okay, only\none more implementation to flesh out with our `.traverse()` method. For this\nimplementation, let's simply print out the values to stdout:\n\n```zig\nconst std = @import(\"std\");\nconst pageAllocator = std.heap.page_allocator;\nconst testing = std.testing;\n\npub fn LinkedList(comptime T: type) type {\n    return struct {\n        // Other stuff...\n\n        // 5. Define a traverse method, printing all the values\n        pub fn traverse(self: *Self) void {\n            // If we don't have a head, there's nothing traverse!\n            if (self.head == null) {\n                return;\n            }\n\n            // We'll walk our linked list as long as there's a next node available\n            var currentNode = self.head;\n\n            while (currentNode != null) : (currentNode = currentNode.?.next) {\n                std.log.info(\"value {}\", .{currentNode.?.value});\n            }\n        }\n    };\n}\n```\n\nSince we're printing node values out to the stdout, it'll be a bit\nhard to verify with a unit test that the printed values are as we expect.\nLet's refactor our code a bit from a library to an executable binary, that\nway we can run our program and visually assert the printed values are correct.\nTo start, let's rename `src/main.zig` to `src/linked_list.zig` and sprinkle\nin a few `pub` keywords to expose the `LinkedList` type itself as well as the\nvarious methods associated to it:\n\n## src/linked_list.zig\n\n```zig\nconst std = @import(\"std\");\nconst pageAllocator = std.heap.page_allocator;\nconst testing = std.testing;\n\npub fn LinkedList(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        // 1. Define a node type\n        const Node = struct {\n            value: T,\n            next: ?*Node,\n        };\n\n        // 2a. Define the linked list properties\n        // There should be three: head, length, and allocator\n        head: ?*Node,\n        length: u32,\n        allocator: std.mem.Allocator,\n\n        // 2b. Add a constructor/initializer for our linked list\n        pub fn new(allocator: std.mem.Allocator) Self {\n            return .{ .length = 0, .head = null, .allocator = allocator };\n        }\n\n        // 3. Define an insert method that takes a generic type value\n        pub fn insert(self: *Self, value: T) !void {\n            // Allocate the memory and create a `Node` for us to use\n            var newNode = try self.allocator.create(Node);\n\n            // Next, set the node value and point it's next value to the current head\n            const currentHead = self.head;\n            newNode.value = value;\n            newNode.next = currentHead;\n\n            // Finally, repoint our head to the new node and increment the count\n            self.head = newNode;\n            self.length += 1;\n        }\n\n        // 4. Define a pop method that removes the last inserted node\n        pub fn pop(self: *Self) ?T {\n            // If we don't have a head, there's no value to pop!\n            if (self.head == null) {\n                return null;\n            }\n\n            // Grab a few temporary values of the current head\n            const currentHead = self.head;\n            const updatedHead = self.head.?.next;\n\n            // Update head and decrement the length now that we're freeing ourselves of a node\n            self.head = updatedHead;\n            self.length -= 1;\n\n            return currentHead.?.value;\n        }\n\n        // 5. Define a traverse method, printing all the values\n        pub fn traverse(self: *Self) void {\n            // If we don't have a head, there's nothing traverse!\n            if (self.head == null) {\n                return;\n            }\n\n            // We'll walk our linked list as long as there's a next node available\n            var currentNode = self.head;\n\n            while (currentNode != null) : (currentNode = currentNode.?.next) {\n                std.log.info(\"value {}\", .{currentNode.?.value});\n            }\n        }\n    };\n}\n\n// None of our test code will change...\n```\n\nWe can keep our inline unit tests the same, and they should still work. Next,\nlet's update our `src/main.zig` file to be just a simple `main()`:\n\n## src/main.zig\n\n```zig\nconst std = @import(\"std\");\nconst linkedList = @import(\"./linked_list.zig\").LinkedList;\n\npub fn main() !void {\n    // Assign an arena allocator for our linked list to use for creating nodes\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    const allocator = arena.allocator();\n\n    // Don't forget to free the memory on exit!\n    defer arena.deinit();\n\n    // Declare our linked list and add a few nodes\n    var u32LinkedList = linkedList(u32).new(allocator);\n    try u32LinkedList.insert(2);\n    try u32LinkedList.insert(3);\n    try u32LinkedList.insert(1);\n\n    // Finally, traverse the list with the output:\n    //    1\n    //    3\n    //    2\n    u32LinkedList.traverse();\n}\n```\n\nOkay, if I'm _hopefully_ doing this right, I'll `@import()` our `LinkedList`\nfrom our local `linked_list.zig` file, spin up an allocator as a linked list dependency,\ninsert a few nodes, and walk the list. One last thing we need to change is our `build.zig` file\nas it's expected to build for a library, not an executable binary. Let's update that\nto add an executable target with a little copy-pasta from a fresh `zig init-exe` test\nexecutable:\n\n## build.zig\n\n```zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.build.Builder) void {\n    // Standard target options allows the person running `zig build` to choose\n    // what target to build for. Here we do not override the defaults, which\n    // means any target is allowed, and the default is native. Other options\n    // for restricting supported target set are available.\n    const target = b.standardTargetOptions(.{});\n\n    // Standard release options allow the person running `zig build` to select\n    // between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall.\n    const mode = b.standardReleaseOptions();\n\n    const exe = b.addExecutable(\"ziggin-around-with-linked-lists\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    exe.install();\n\n    const run_cmd = exe.run();\n    run_cmd.step.dependOn(b.getInstallStep());\n    if (b.args) |args| {\n        run_cmd.addArgs(args);\n    }\n\n    const run_step = b.step(\"run\", \"Run the app\");\n    run_step.dependOn(&run_cmd.step);\n\n    const exe_tests = b.addTest(\"src/main.zig\");\n    exe_tests.setTarget(target);\n    exe_tests.setBuildMode(mode);\n\n    const test_step = b.step(\"test\", \"Run unit tests\");\n    test_step.dependOn(&exe_tests.step);\n}\n```\n\nNote the key changes being our builder calling `.addExecutable()` and running\nthe program with `exe.run()`. Let's take this for a spin now and see what we get:\n\n```shell\n$ zig build run\ninfo: value 1\ninfo: value 3\ninfo: value 2\n```\n\nAlright, just like we expected! Since we did a bit of refactoring, let's\nmake sure our tests still pass. We're building in the context of a runnable\nprogram, so we can directly test our `linked_list.zig` file with the toolchain:\n\n```shell\n$ zig test src/linked_list.zig\nAll 6 tests passed.\n```\n\nAnd once again, we have passing tests!\n\n## Wrapping up\n\nI'm gonna call that a wrap for now, as our (poor man's) linked\nlist is looking pretty good and functioning as we expect. I'll be looking to a bit more Zig to spice up my daily\ndeveloper life when I can.\nZig feels a lot like Rust with much of the same safety guarantees and is just plain fun to write.\n\nUntil next time, friends!\n",
    "html": "<p>So I've been looking for a reason to write code to keep me sane while in the\nthick of parental leave, and I, like I'm sure most of us have seen on tech bro Twitter, have been seeing a lot of\ncommotion about <a href=\"https://Ziglang.org\">Zig</a>.\nI've been writing quite a bit of Rust, and Zig's model of no hidden memory\nallocation or hidden control flow is fascinating to me.</p>\n<p>Much like Rust's upfront model of memory safety first, becoming conscious\nof borrows (with lots of help from the compiler) definitely made me\nmore aware of <em>what</em> exactly I was doing in code rather than passing\nobjects (and thus, memory) around willy nilly. Those that have read a\nfew things around here know that I'm married to .NET during my 8-to-5,\nwhere corporate .NET developer America is not concerned\nmuch about zero cost abstractions and memory safety.</p>\n<p>I wanted to get down and dirty with some Zig, and what better way to\nthan to take a trip down CS-from-college memory lane: implementing a (poor man's)\nlinked list! I like to drink from the fire hose, so to speak, when learning\na new language so I'll treat this blog post as a live look into my trials\nand tribulations of getting started with Zig.</p>\n<p>As always, you can find all the sample source code we'll be writing in this blog\npost available on <a href=\"https://github.com/JoeyMckenzie/joey-mckenzie-tech/tree/main/samples/zig/with-linked-lists\">my blog</a>,\nso feel free to reference it any time.</p>\n<h2>Getting started with Zig</h2>\n<p>Okay, so I want to implement a linked list with Zig. I'm definitely going\nto need a Zig toolchain on my machine. Luckily, the docs have me covered.\nI'm on WSL using Ubuntu 22.04, so I'll use <a href=\"https://snapcraft.io/\">snap</a> to\ninstall the Zig toolchain:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> snap</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> Zig</span><span style=\"color:#79B8FF\"> --classic</span><span style=\"color:#79B8FF\"> --beta</span></span></code></pre></figure>\n<p>There's an option to install the latest version of Zig from master using the\n<code>--edge</code> flag in place of <code>--beta</code>, but I have no idea what I'm doing with Zig\nyet so the latest stable version should do me just fine. Okay, got Zig installed,\nlet's check the version:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> zig</span><span style=\"color:#9ECBFF\"> version</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">0.10.1</span></span></code></pre></figure>\n<p>Nice! Zig was successfully installed, so let's spin up a simple library\nsimilar to something like <code>cargo new --lib my-lib</code>. We'll use a library in this\ncase as we don't need really need run anything in the console, writing and running\na few tests to assert our linked list's behavior is correct should suffice.</p>\n<p>Okay, according to the docs, a <code>Zig init-lib</code> should do the trick:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> mkdir</span><span style=\"color:#9ECBFF\"> Ziggin-around-with-linked-lists</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">$_</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> zig</span><span style=\"color:#9ECBFF\"> init-lib</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">info:</span><span style=\"color:#9ECBFF\"> Created</span><span style=\"color:#9ECBFF\"> build.zig</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">info:</span><span style=\"color:#9ECBFF\"> Created</span><span style=\"color:#9ECBFF\"> src/main.zig</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">info:</span><span style=\"color:#9ECBFF\"> Next,</span><span style=\"color:#9ECBFF\"> try</span><span style=\"color:#9ECBFF\"> `</span><span style=\"color:#B392F0\">Zig</span><span style=\"color:#9ECBFF\"> build </span><span style=\"color:#79B8FF\">--help</span><span style=\"color:#9ECBFF\">`</span><span style=\"color:#B392F0\"> or</span><span style=\"color:#9ECBFF\"> `</span><span style=\"color:#B392F0\">Zig</span><span style=\"color:#9ECBFF\"> build test`</span></span></code></pre></figure>\n<p>Sweet! I see two files now, <code>src/main.zig</code> and <code>build.zig</code>. Let's crack open the\nbuild file to make some sense of it:</p>\n<h2>build.zig</h2>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> build</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">build</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">Builder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Standard release options allow the person running `Zig build` to select</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall.</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">standardReleaseOptions</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> lib</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">addStaticLibrary</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Zig-test\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"src/main.zig\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    lib</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">setBuildMode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mode</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    lib</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">install</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> main_tests</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">addTest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"src/main.zig\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    main_tests</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">setBuildMode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mode</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> test_step</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">step</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Run library tests\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    test_step</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">dependOn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">main_tests</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">step</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Okay, parsing this file a bit, it looks like there are a few things going on:</p>\n<ul>\n<li>Zig doesn't have an official package manager yet (at least from what I can see) on the stable branch, though it's\ncoming soontm</li>\n<li>Zig's build feels a lot like Rust's version of a <code>build.rs</code> file you'll see from time to time, so that's neat</li>\n<li>Since we're in the context of a library, our default build target will just run tests\nas we're not building an executable</li>\n</ul>\n<p>Alright, I <em>think</em> I've got the basics down here. Cross-referencing the docs about\nits <a href=\"https://Ziglearn.org/chapter-3/\">build system</a>\nseems to confirm what I'm looking here. Next, let's take a look at <code>main.zig</code>:</p>\n<h2>src/main.zig</h2>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> testing</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">i32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">i32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">i32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    return</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#F97583\"> +</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">test</span><span style=\"color:#9ECBFF\"> \"basic add functionality\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Let's take a swing at parsing this thing while cross-checking with the docs:</p>\n<ul>\n<li>Imports defined at the top with <code>@import</code> - pretty cool, feels a lot like other languages</li>\n<li>We export a single <code>add</code> function that returns an <code>i32</code> - feels pretty similar to Go and Rust integer types</li>\n<li>There's a testing block with a short description - pretty neat, feels a bit jest-like</li>\n<li>We <code>try</code> to make an assertion - <code>try</code> in Zig is pretty neat\n<ul>\n<li><code>try</code> feels a lot like Rust's try operator in <code>?</code> or Go's abundant <code>if err != nil { ... }</code> you'll see everywhere</li>\n<li>In essence: attempt an operation and if it fails, simply return the error back to the caller</li>\n</ul>\n</li>\n</ul>\n<p>Okay, think I've got a hang of this so far. I'm loosely in line with my pontification and the docs, so let's give this\nthing a go:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> zig</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> test</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">All</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#9ECBFF\"> tests</span><span style=\"color:#9ECBFF\"> passed.</span></span></code></pre></figure>\n<p>Nice, our tests passed! Adding two numbers is fun and all,\nbut let's kick it up a notch by building a simple linked list.</p>\n<h2>Linked lists for fun</h2>\n<p>There are a thousand other resources for learning about what a linked list is\nand why they are useful. I'm not exactly the person\nto listen to when it comes to that arena, so I'll leave it to the academics\nand the LinkedIn tech influencers to do a much better job than I will\nwhen discussing linked lists.</p>\n<p>Without going too far down the CS rabbit hole, our version of a linked list\nwill be fairly straightforward. Our linked list will have:</p>\n<ul>\n<li>A head node</li>\n<li>A way to keep track of the length</li>\n<li>A few operations associated to it:\n<ul>\n<li>An <code>insert</code> method that will attach new nodes to the head</li>\n<li>A <code>pop</code> method that will detach the most recently inserted node and read out their values</li>\n<li>A <code>traverse</code> method will walk the linked list and print out values as it goes</li>\n</ul>\n</li>\n</ul>\n<p>There's a lot more to a linked list than the operations we defined above - for example,\none could insert at <em>any</em> point in the linked list rather than the head, or peek values\nat the tail rather than explicitly removing them. I'll leave those as an exercise for the reader.</p>\n<p>Let's get started by scaffolding out a simple <code>struct</code> that will be our linked list. Let's create a <code>linked_list.zig</code>\nfile adjacent to our <code>main.zig</code> in our <code>src/</code> directory and get some boilerplate in place:</p>\n<h2>src/linked_list.zig</h2>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> const</span><span style=\"color:#FFAB70\"> LinkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // 1. Define a node type</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // 2. Define the linked list properties</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // There should be three: head, tail, and length</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // 3. Define an insert method that takes a generic type</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // 4. Define a pop method</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // 5. Define a traverse method, printing all the values</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></figure>\n<p>Taking a look, Zig has <code>struct</code>s much like Go and Rust - nothing new here. Now,\nI <em>do</em> want this to be a generic linked list over some type of my choosing. Skimming\nthrough the docs, looks like I need to do a bit of higher-order goodness with <code>comptime</code>\ntypes to get this working. Let's adjust this code so our <code>LinkedList</code> is actually a function <code>fn</code> that will take in a\ngeneric <code>comptime</code> type and return a <code>struct</code> that's generic over it:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">fn</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">comptime</span><span style=\"color:#FFAB70\"> T</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 1. Define a node type</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        const</span><span style=\"color:#FFAB70\"> Node</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">) };</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2. Define the linked list properties</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // There should be three: head, tail, and length</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 3. Define an insert method that takes a generic type</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 4. Define a pop method</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 5. Define a traverse method, printing all the values</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Cool, I've got a generic struct so far and also defined a new internal <code>Node</code> type\nto house the generic type value that we'll use when creating new nodes on the linked list\nthat also points to the next node in the list. We'll reach for Zig's <code>?</code> operator as a form\nof optional chaining, telling the compiler \"hey, this <code>Node</code> here could be <code>null</code>, so make sure to enforce checking that\nbefore dereferencing it\" and also slap a <code>*</code> afterwards to signal that this is a <em>pointer</em> to another node, not the node\nitself.</p>\n<p>Okay, I'm liking this so far. Zig feels a bit like Go, a bit like Rust, and a bit like C\n(I cut my teach on Fortran starting out, don't judge me). Let's add a few properties\nto our linked list now:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">fn</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">comptime</span><span style=\"color:#FFAB70\"> T</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 1. Define a node type</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        const</span><span style=\"color:#FFAB70\"> Node</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2a. Define the linked list properties</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        head</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        length</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2b. Add a constructor/initializer for our linked list</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> new</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">){ .</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, .</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">null</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 3. Define an insert method that takes a generic type</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 4. Define a pop method</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 5. Define a traverse method, printing all the values</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Okay, so we added <code>head</code> and <code>length</code> properties as well as a\nconstructor with <code>fn new()</code> to initialize our linked list. So far, so good.\nWe have the world's most basic linked list that does and contains... absolutely nothing.\nLet's write some tests to verify the nothingness:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">test</span><span style=\"color:#9ECBFF\"> \"initializing builds an empty linked list with no nodes\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Our test is pretty basic, just asserting there's no length or head when initializing\nour linked list. Let's run this:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> zig</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> test</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">All</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#9ECBFF\"> tests</span><span style=\"color:#9ECBFF\"> passed.</span></span></code></pre></figure>\n<p>Passing tests for our useless linked list, huzzah!</p>\n<p>Since my brain is still in Rust-land, I look at <code>try</code> keywords in a similar fashion to Rust's <code>?</code>,\nsimply propagating errors back to the caller. Our linked list isn't anything special (yet), so let's\nstart building out some nice functionality to at least let caller's insert new nodes at the head.\nBefore we do that, let's channel our inner TDD and write a test that we know will fail, <em>then</em> write\nthe code to make inserting nodes pass, firstly adding a bare implementation of <code>insert()</code> to our\n<code>LinkedList</code> struct:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">fn</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">comptime</span><span style=\"color:#FFAB70\"> T</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        const</span><span style=\"color:#FFAB70\"> Self</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@This</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 1. Define a node type</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        const</span><span style=\"color:#FFAB70\"> Node</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2a. Define the linked list properties</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        head</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        length</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2b. Add a constructor/initializer for our linked list</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        fn</span><span style=\"color:#B392F0\"> new</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> .{ .</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, .</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">null</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 3. Define an insert method that takes a generic type value</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        fn</span><span style=\"color:#B392F0\"> insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">_</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">_</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 4. Define a pop method</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 5. Define a traverse method, printing all the values</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>After a bit of digging, we need to add the line for <code>const Self = @This()</code> to signal\nthat the internal struct methods are methods associated to the struct itself,\nnot static functions callable without an object reference. This feels a lot like\nthe <code>&#x26;self</code> argument you'll see when implementing traits or defining struct\nmethods in Rust, so we'll add it to get the same functionality. Now, let's\nwrite the tests:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\"> test</span><span style=\"color:#9ECBFF\"> \"inserting a value appends to the head of the linked list\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // arrange</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // act</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">69</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // assert</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#79B8FF\"> 69</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>We're tapping into Zig's optional unwrapping mechanism for struct values\nwith <code>.?.value</code>. Now if we if we run our tests...</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> zig</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> test</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">Test</span><span style=\"color:#E1E4E8\"> [2/2] test.inserting a value appends to the head of the linked list... FAIL (</span><span style=\"color:#B392F0\">TestUnexpectedResult</span><span style=\"color:#E1E4E8\">)</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">/snap/Zig/6352/lib/std/testing.zig:347:14:</span><span style=\"color:#79B8FF\"> 0x211627</span><span style=\"color:#9ECBFF\"> in</span><span style=\"color:#9ECBFF\"> expect</span><span style=\"color:#E1E4E8\"> (test)</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">ok</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> error.TestUnexpectedResult;</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">             ^</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">/home/jmckenzie/projects/Rust/joey-mckenzie-tech/samples/Ziggin-around-with-linked-lists/src/main.zig:51:5:</span><span style=\"color:#79B8FF\"> 0x21186e</span><span style=\"color:#9ECBFF\"> in</span><span style=\"color:#9ECBFF\"> test.inserting</span><span style=\"color:#9ECBFF\"> a</span><span style=\"color:#9ECBFF\"> value</span><span style=\"color:#9ECBFF\"> appends</span><span style=\"color:#9ECBFF\"> to</span><span style=\"color:#9ECBFF\"> the</span><span style=\"color:#9ECBFF\"> head</span><span style=\"color:#9ECBFF\"> of</span><span style=\"color:#9ECBFF\"> the</span><span style=\"color:#9ECBFF\"> linked</span><span style=\"color:#9ECBFF\"> list</span><span style=\"color:#E1E4E8\"> (test)</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    try</span><span style=\"color:#9ECBFF\"> std.testing.expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">linkedList.length</span><span style=\"color:#9ECBFF\"> ==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">    ^</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">1</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#B392F0\">0</span><span style=\"color:#9ECBFF\"> skipped</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#B392F0\">1</span><span style=\"color:#9ECBFF\"> failed.</span></span></code></pre></figure>\n<p>Awesome, our tests failed! But that's okay because that was to be expected.\nNow let's implement our <code>insert()</code> method to make them pass:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">fn</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">comptime</span><span style=\"color:#FFAB70\"> T</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        const</span><span style=\"color:#FFAB70\"> Self</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@This</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 1. Define a node type</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        const</span><span style=\"color:#FFAB70\"> Node</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            value</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            next</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2a. Define the linked list properties</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        head</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        length</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        allocator</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">mem</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">Allocator</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2b. Add a constructor/initializer for our linked list</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        fn</span><span style=\"color:#B392F0\"> new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">mem</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">Allocator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> .{ .</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, .</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">null</span><span style=\"color:#E1E4E8\">, .</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 3. Define an insert method that takes a generic type value</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        fn</span><span style=\"color:#B392F0\"> insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Allocate the memory and create a `Node` for us to use</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            var</span><span style=\"color:#FFAB70\"> newNode</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">try</span><span style=\"color:#FFAB70\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Next, set the node value and point it's next value to the current head</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            const</span><span style=\"color:#FFAB70\"> currentHead</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            newNode</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            newNode</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">currentHead</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Finally, repoint our head to the new node and increment the count</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">newNode</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> +=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 4. Define a pop method</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 5. Define a traverse method, printing all the values</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 6. Extra credit: define an insertAt method</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Okay, a few things have changed. We've added an <code>allocator</code> property that's\nof type <code>std.mem.Allocator</code> - remember how we mentioned Zig's use of no hidden memory allocations?\nWell if we want to create structs, we need to allocate the memory manually to do so. This is\nwhere a <code>std.mem.Allocator</code> comes in handy. There are several different types of allocators\nin Zig's standard library, though we'll use the <a href=\"https://Ziglearn.org/chapter-2/\">arena allocator</a>\nas skimming the docs seems like the best strategy for now for a Zig noobie like myself. We purposely avoid\nstrongly coupling to the allocator type in our linked list and force our callers to provide\none to make things a bit more flexible, as tomorrow we might wake up and decide\nto use a <code>GeneralPurposeAllocator</code> instead. Let's update our tests to use the <code>ArenaAllocator</code>:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">test</span><span style=\"color:#9ECBFF\"> \"initializing builds an empty linked list with no head or tail\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // arrange, setup and allocator for our linked list to create nodes internally</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">ArenaAllocator</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">page_allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">deinit</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">allocator</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // act/assert</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">test</span><span style=\"color:#9ECBFF\"> \"inserting a value appends to the head of the linked list\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // arrange</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">ArenaAllocator</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">page_allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">deinit</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">allocator</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // act</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">69</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // assert</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 69</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Though we're running single process unit tests that aren't long running (they start and stop\nwithout using much in terms of resources from our machine) and probably don't need to manually free memory\nwith the calls to <code>defer arena.deinit()</code>, it's a good habit to form to get used to manually\nmanaging and freeing allocated memory. We might also benefit from being able to free memory\nfrom within our <code>LinkedList</code> as well by adding a wrapping call in the form\nof <code>fn free(self: *Self) !void { // Free the memory }</code>,\nbut I'll save that for a rainy day as I still have fairly no clue what I'm doing with Zig.</p>\n<p>We also need to slap some <code>try</code>s to our <code>insert()</code> method\nnow that its return signature is <code>!void</code> instead of just <code>void</code> - errors can occur while\nallocating memory, so we need to explicitly state that in our signature with a prefixed <code>!</code> operator before our return\ntype (<code>void</code> in this case). Okay, our tests\nare updated to handle/return the errors. Let's run our tests now:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> zig</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> test</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">All</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#9ECBFF\"> tests</span><span style=\"color:#9ECBFF\"> passed.</span></span></code></pre></figure>\n<p>Nice, passing tests that are <em>actually</em> somewhat legit now! What happens if\nwe insert multiple values into the linked list? Let's write a test\nfor this case:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">test</span><span style=\"color:#9ECBFF\"> \"inserting multiple values correctly updates head\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // arrange</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">ArenaAllocator</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">page_allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">deinit</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">allocator</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // act</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">69</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">420</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1337</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // assert</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 1337</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Running our tests again, and they pass without needing to update our\nimplementation, nice! Okay, we're getting the hang of things... let's\nkick it up another notch and flesh out our pop method. Let's flesh out the bare minimum case:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">fn</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">comptime</span><span style=\"color:#FFAB70\"> T</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // Other stuff...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 4. Define a pop method</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        fn</span><span style=\"color:#B392F0\"> pop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">_</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\">) ?</span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>And next, let's add the tests that we know will fail:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">test</span><span style=\"color:#9ECBFF\"> \"popping nodes off the linked list returns a value\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // arrange</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> gpa</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">GeneralPurposeAllocator</span><span style=\"color:#E1E4E8\">(.{}){};</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">gpa</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">allocator</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // act, with order 1337 -> 420 -> 69 -> null</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">69</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">420</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1337</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // after popping, our list should be 420 -> 69 -> null</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> poppedValue</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // assert</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 420</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">poppedValue</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">poppedValue</span><span style=\"color:#E1E4E8\">.? </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1337</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Our tests fail when we run them, so let's flesh out our <code>.pop()</code> implementation\nnow to get them passing:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">fn</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">comptime</span><span style=\"color:#FFAB70\"> T</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // Other stuff...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 4. Define a pop method</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        fn</span><span style=\"color:#B392F0\"> pop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\">) ?</span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // If we don't have a head, there's no value to pop!</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                return</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Grab a few temporary values of the current head</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            const</span><span style=\"color:#FFAB70\"> currentHead</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            const</span><span style=\"color:#FFAB70\"> updatedHead</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Update head and decrement the length now that we're freeing ourselves of a node</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">updatedHead</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> -=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">            return</span><span style=\"color:#FFAB70\"> currentHead</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Once again, if we run our tests, we should see four now passing in the console. Sweet!\nBut wait... what happens if we <code>.pop()</code> on a single-item linked list? In theory, we should\nget the value as it'll be the only node in the list. Let's verify that our implementation\ncovers this case with yet another test:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">test</span><span style=\"color:#9ECBFF\"> \"popping a node off a linked list with one item returns it's value\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // arrange, setup and allocator for our linked list to create nodes internally</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">ArenaAllocator</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageAllocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">deinit</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">allocator</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // act</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">69</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> poppedValue</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // assert</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">poppedValue</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">poppedValue</span><span style=\"color:#E1E4E8\">.? </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 69</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Running the tests again, looks like we're covered for the case of\na single-item linked list. What happens if we <code>.pop()</code> on a linked list\nwith no items? In theory, we shouldn't get any values returned, but let's\nverify with a test:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">test</span><span style=\"color:#9ECBFF\"> \"popping a node off an empty linked list returns null\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // arrange, setup and allocator for our linked list to create nodes internally</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">ArenaAllocator</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageAllocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">deinit</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">allocator</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // act</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> poppedValue</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // assert</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">linkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">poppedValue</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Running the tests yet again yields passing results! Okay, only\none more implementation to flesh out with our <code>.traverse()</code> method. For this\nimplementation, let's simply print out the values to stdout:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> pageAllocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">page_allocator</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> testing</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">comptime</span><span style=\"color:#FFAB70\"> T</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // Other stuff...</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 5. Define a traverse method, printing all the values</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> traverse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // If we don't have a head, there's nothing traverse!</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // We'll walk our linked list as long as there's a next node available</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            var</span><span style=\"color:#FFAB70\"> currentNode</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">currentNode</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">) : (</span><span style=\"color:#FFAB70\">currentNode</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">currentNode</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">                std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">log</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"value {}\"</span><span style=\"color:#E1E4E8\">, .{</span><span style=\"color:#FFAB70\">currentNode</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">});</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Since we're printing node values out to the stdout, it'll be a bit\nhard to verify with a unit test that the printed values are as we expect.\nLet's refactor our code a bit from a library to an executable binary, that\nway we can run our program and visually assert the printed values are correct.\nTo start, let's rename <code>src/main.zig</code> to <code>src/linked_list.zig</code> and sprinkle\nin a few <code>pub</code> keywords to expose the <code>LinkedList</code> type itself as well as the\nvarious methods associated to it:</p>\n<h2>src/linked_list.zig</h2>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> pageAllocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">page_allocator</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> testing</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">testing</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> LinkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">comptime</span><span style=\"color:#FFAB70\"> T</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        const</span><span style=\"color:#FFAB70\"> Self</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@This</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 1. Define a node type</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        const</span><span style=\"color:#FFAB70\"> Node</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            value</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            next</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2a. Define the linked list properties</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // There should be three: head, length, and allocator</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        head</span><span style=\"color:#E1E4E8\">: ?</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        length</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        allocator</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">mem</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">Allocator</span><span style=\"color:#E1E4E8\">,</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 2b. Add a constructor/initializer for our linked list</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">mem</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">Allocator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> .{ .</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, .</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">null</span><span style=\"color:#E1E4E8\">, .</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 3. Define an insert method that takes a generic type value</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Allocate the memory and create a `Node` for us to use</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            var</span><span style=\"color:#FFAB70\"> newNode</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#F97583\">try</span><span style=\"color:#FFAB70\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">Node</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Next, set the node value and point it's next value to the current head</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            const</span><span style=\"color:#FFAB70\"> currentHead</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            newNode</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            newNode</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">currentHead</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Finally, repoint our head to the new node and increment the count</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">newNode</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> +=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 4. Define a pop method that removes the last inserted node</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> pop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\">) ?</span><span style=\"color:#FFAB70\">T</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // If we don't have a head, there's no value to pop!</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                return</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Grab a few temporary values of the current head</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            const</span><span style=\"color:#FFAB70\"> currentHead</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            const</span><span style=\"color:#FFAB70\"> updatedHead</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // Update head and decrement the length now that we're freeing ourselves of a node</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">updatedHead</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">            self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> -=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">            return</span><span style=\"color:#FFAB70\"> currentHead</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">        // 5. Define a traverse method, printing all the values</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">        pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> traverse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">Self</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // If we don't have a head, there's nothing traverse!</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">            // We'll walk our linked list as long as there's a next node available</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">            var</span><span style=\"color:#FFAB70\"> currentNode</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">currentNode</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> null</span><span style=\"color:#E1E4E8\">) : (</span><span style=\"color:#FFAB70\">currentNode</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">currentNode</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">                std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">log</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"value {}\"</span><span style=\"color:#E1E4E8\">, .{</span><span style=\"color:#FFAB70\">currentNode</span><span style=\"color:#E1E4E8\">.?.</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">});</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">// None of our test code will change...</span></span></code></pre></figure>\n<p>We can keep our inline unit tests the same, and they should still work. Next,\nlet's update our <code>src/main.zig</code> file to be just a simple <code>main()</code>:</p>\n<h2>src/main.zig</h2>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> linkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"./linked_list.zig\"</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#FFAB70\">LinkedList</span><span style=\"color:#E1E4E8\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Assign an arena allocator for our linked list to use for creating nodes</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">ArenaAllocator</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">heap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">page_allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> allocator</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">allocator</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Don't forget to free the memory on exit!</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#FFAB70\"> arena</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">deinit</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Declare our linked list and add a few nodes</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    var</span><span style=\"color:#FFAB70\"> u32LinkedList</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#B392F0\">linkedList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">u32</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">allocator</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> u32LinkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> u32LinkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    try</span><span style=\"color:#FFAB70\"> u32LinkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Finally, traverse the list with the output:</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    //    1</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    //    3</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    //    2</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    u32LinkedList</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">traverse</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Okay, if I'm <em>hopefully</em> doing this right, I'll <code>@import()</code> our <code>LinkedList</code>\nfrom our local <code>linked_list.zig</code> file, spin up an allocator as a linked list dependency,\ninsert a few nodes, and walk the list. One last thing we need to change is our <code>build.zig</code> file\nas it's expected to build for a library, not an executable binary. Let's update that\nto add an executable target with a little copy-pasta from a fresh <code>zig init-exe</code> test\nexecutable:</p>\n<h2>build.zig</h2>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"zig\" data-theme=\"github-dark\"><code data-language=\"zig\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#F97583\">const</span><span style=\"color:#FFAB70\"> std</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#79B8FF\">@import</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">pub</span><span style=\"color:#F97583\"> fn</span><span style=\"color:#B392F0\"> build</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">std</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">build</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">Builder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Standard target options allows the person running `zig build` to choose</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // what target to build for. Here we do not override the defaults, which</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // means any target is allowed, and the default is native. Other options</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // for restricting supported target set are available.</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> target</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">standardTargetOptions</span><span style=\"color:#E1E4E8\">(.{});</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // Standard release options allow the person running `zig build` to select</span></span>\n<span data-line=\"\"><span style=\"color:#6A737D\">    // between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall.</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">standardReleaseOptions</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> exe</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">addExecutable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ziggin-around-with-linked-lists\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"src/main.zig\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    exe</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">setTarget</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    exe</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">setBuildMode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mode</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    exe</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">install</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> run_cmd</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">exe</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">();</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    run_cmd</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">step</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">dependOn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">getInstallStep</span><span style=\"color:#E1E4E8\">());</span></span>\n<span data-line=\"\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">        run_cmd</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">addArgs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> run_step</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">step</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"run\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Run the app\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    run_step</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">dependOn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">run_cmd</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">step</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> exe_tests</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">addTest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"src/main.zig\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    exe_tests</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">setTarget</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    exe_tests</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">setBuildMode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mode</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"color:#F97583\">    const</span><span style=\"color:#FFAB70\"> test_step</span><span style=\"color:#E1E4E8\"> = </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">step</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Run unit tests\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#FFAB70\">    test_step</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">dependOn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">exe_tests</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#FFAB70\">step</span><span style=\"color:#E1E4E8\">);</span></span>\n<span data-line=\"\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></figure>\n<p>Note the key changes being our builder calling <code>.addExecutable()</code> and running\nthe program with <code>exe.run()</code>. Let's take this for a spin now and see what we get:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> zig</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> run</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">info:</span><span style=\"color:#9ECBFF\"> value</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">info:</span><span style=\"color:#9ECBFF\"> value</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">info:</span><span style=\"color:#9ECBFF\"> value</span><span style=\"color:#79B8FF\"> 2</span></span></code></pre></figure>\n<p>Alright, just like we expected! Since we did a bit of refactoring, let's\nmake sure our tests still pass. We're building in the context of a runnable\nprogram, so we can directly test our <code>linked_list.zig</code> file with the toolchain:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\" data-language=\"shell\" data-theme=\"github-dark\"><code data-language=\"shell\" data-theme=\"github-dark\" style=\"display: grid;\"><span data-line=\"\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> zig</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> src/linked_list.zig</span></span>\n<span data-line=\"\"><span style=\"color:#B392F0\">All</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#9ECBFF\"> tests</span><span style=\"color:#9ECBFF\"> passed.</span></span></code></pre></figure>\n<p>And once again, we have passing tests!</p>\n<h2>Wrapping up</h2>\n<p>I'm gonna call that a wrap for now, as our (poor man's) linked\nlist is looking pretty good and functioning as we expect. I'll be looking to a bit more Zig to spice up my daily\ndeveloper life when I can.\nZig feels a lot like Rust with much of the same safety guarantees and is just plain fun to write.</p>\n<p>Until next time, friends!</p>"
  },
  "_id": "2023/ziggin-around-with-linked-lists.md",
  "_raw": {
    "sourceFilePath": "2023/ziggin-around-with-linked-lists.md",
    "sourceFileName": "ziggin-around-with-linked-lists.md",
    "sourceFileDir": "2023",
    "contentType": "markdown",
    "flattenedPath": "2023/ziggin-around-with-linked-lists"
  },
  "type": "Post",
  "url": "/blog/2023/ziggin-around-with-linked-lists"
}